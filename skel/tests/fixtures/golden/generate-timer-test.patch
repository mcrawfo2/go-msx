--- before/plain-root.txtar
+++ golden/generate-timer-test.txtar
@@ -1466,4 +1466,9 @@
   reporter:
     name: zipkin
+
+consul.leader.election:
+  enabled: true
+
+scheduled.tasks.wabbit.fixed-interval: 15m
 -- someservice/cmd/app/main.go --
 package main
@@ -1473,4 +1478,5 @@
 	"cto-github.cisco.com/NFV-BU/go-msx/app"
 	_ "cto-github.cisco.com/NFV-BU/someservice/internal/migrate"
+	_ "cto-github.cisco.com/NFV-BU/someservice/internal/timer/wabbits"
 )
 
@@ -2351,4 +2357,142 @@
 	_ "cto-github.cisco.com/NFV-BU/someservice/internal/migrate/V5_0_0"
 )
+-- someservice/internal/timer/wabbits/mock_timer_wabbit.go --
+// Code generated by mockery v2.21.1. DO NOT EDIT.
+
+package wabbits
+
+import (
+	context "context"
+
+	mock "github.com/stretchr/testify/mock"
+)
+
+// MockWabbitTimer is an autogenerated mock type for the WabbitTimerApi type
+type MockWabbitTimer struct {
+	mock.Mock
+}
+
+// Run provides a mock function with given fields: ctx
+func (_m *MockWabbitTimer) Run(ctx context.Context) error {
+	ret := _m.Called(ctx)
+
+	var r0 error
+	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
+		r0 = rf(ctx)
+	} else {
+		r0 = ret.Error(0)
+	}
+
+	return r0
+}
+
+type mockConstructorTestingTNewMockWabbitTimer interface {
+	mock.TestingT
+	Cleanup(func())
+}
+
+// NewMockWabbitTimer creates a new instance of MockWabbitTimer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
+func NewMockWabbitTimer(t mockConstructorTestingTNewMockWabbitTimer) *MockWabbitTimer {
+	mock := &MockWabbitTimer{}
+	mock.Mock.Test(t)
+
+	t.Cleanup(func() { mock.AssertExpectations(t) })
+
+	return mock
+}
+-- someservice/internal/timer/wabbits/pkg.go --
+package wabbits
+
+import "cto-github.cisco.com/NFV-BU/go-msx/log"
+
+type contextKey string
+
+var logger = log.NewLogger("someservice.internal.timer.wabbits")
+-- someservice/internal/timer/wabbits/timer_wabbit.go --
+//go:generate mockery --inpackage --name=WabbitTimerApi --structname=MockWabbitTimer --filename mock_timer_wabbit.go
+package wabbits
+
+import (
+	"context"
+	"cto-github.cisco.com/NFV-BU/go-msx/app"
+	"cto-github.cisco.com/NFV-BU/go-msx/config"
+	"cto-github.cisco.com/NFV-BU/go-msx/leader"
+	"cto-github.cisco.com/NFV-BU/go-msx/scheduled"
+	"cto-github.cisco.com/NFV-BU/go-msx/types"
+)
+
+const (
+	contextKeyWabbitTimer = contextKey("wabbitTimer")
+	configRootWabbitTimer = "someservice.wabbit.timer"
+	taskNameWabbit        = "wabbit"
+)
+
+type WabbitTimerApi interface {
+	Run(ctx context.Context) error
+}
+
+type wabbitTimer struct {
+	cfg *wabbitTimerConfig
+}
+
+type wabbitTimerConfig struct {
+}
+
+func newWabbitTimerConfig(ctx context.Context) (*wabbitTimerConfig, error) {
+	var cfg wabbitTimerConfig
+	if err := config.FromContext(ctx).Populate(&cfg, configRootWabbitTimer); err != nil {
+		return nil, err
+	}
+	return &cfg, nil
+}
+
+func (t *wabbitTimer) Run(ctx context.Context) error {
+	// TODO : Implement
+	return nil
+}
+
+func newWabbitTimer(ctx context.Context) (WabbitTimerApi, error) {
+	timer := WabbitTimerFromContext(ctx)
+	if timer == nil {
+		cfg, err := newWabbitTimerConfig(ctx)
+		if err != nil {
+			return nil, err
+		}
+
+		timer = &wabbitTimer{
+			cfg: cfg,
+		}
+	}
+	return timer, nil
+}
+
+func WabbitTimerFromContext(ctx context.Context) WabbitTimerApi {
+	value, _ := ctx.Value(contextKeyWabbitTimer).(WabbitTimerApi)
+	return value
+}
+
+func ContextWithWabbitTimer(ctx context.Context, timer WabbitTimerApi) context.Context {
+	return context.WithValue(ctx, contextKeyWabbitTimer, timer)
+}
+
+func init() {
+	var timer WabbitTimerApi
+
+	app.OnRootEvent(app.EventStart, app.PhaseDuring, func(ctx context.Context) (err error) {
+		timer, err = newWabbitTimer(ctx)
+		if err != nil {
+			return err
+		}
+		return
+	})
+
+	app.OnRootEvent(app.EventStart, app.PhaseAfter, func(ctx context.Context) error {
+		operation := types.
+			NewOperation(timer.Run).
+			WithDecorator(leader.MasterLeaderDecorator)
+
+		return scheduled.ScheduleTask(ctx, taskNameWabbit, operation.Run)
+	})
+}
 -- someservice/local/someservice.remote.yml --
 remote.service.address: 192.168.1.2
