<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>go-msx</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.1.</strong> Module Overview</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Cross-Cutting Concerns</li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">2.</strong> Logging</a></li><li class="chapter-item expanded "><a href="types/docs/errors.html"><strong aria-hidden="true">3.</strong> Errors</a></li><li class="chapter-item expanded "><a href="config/index.html"><strong aria-hidden="true">4.</strong> Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/consulprovider/index.html"><strong aria-hidden="true">4.1.</strong> Consul Configuration Provider</a></li></ol></li><li class="chapter-item expanded "><a href="app/index.html"><strong aria-hidden="true">5.</strong> Lifecycle</a></li><li class="chapter-item expanded "><a href="app/context.html"><strong aria-hidden="true">6.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="stats/index.html"><strong aria-hidden="true">7.</strong> Stats</a></li><li class="chapter-item expanded "><a href="trace/index.html"><strong aria-hidden="true">8.</strong> Tracing</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Application Patterns</li><li class="chapter-item expanded "><a href="types/docs/operations.html"><strong aria-hidden="true">9.</strong> Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/docs/middleware.html"><strong aria-hidden="true">9.1.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="types/docs/decorators.html"><strong aria-hidden="true">9.2.</strong> Decorators</a></li><li class="chapter-item expanded "><a href="types/docs/filters.html"><strong aria-hidden="true">9.3.</strong> Filters</a></li><li class="chapter-item expanded "><a href="trace/docs/operations.html"><strong aria-hidden="true">9.4.</strong> Traced Operations</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Handlers</div></li></ol></li><li class="chapter-item expanded "><a href="ops/docs/ports.html"><strong aria-hidden="true">10.</strong> Ports</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ops/docs/input-ports.html"><strong aria-hidden="true">10.1.</strong> Input Ports</a></li><li class="chapter-item expanded "><a href="ops/docs/output-ports.html"><strong aria-hidden="true">10.2.</strong> Output Ports</a></li><li class="chapter-item expanded "><a href="ops/docs/validation.html"><strong aria-hidden="true">10.3.</strong> Validation</a></li></ol></li><li class="chapter-item expanded "><a href="types/docs/services.html"><strong aria-hidden="true">11.</strong> Services</a></li><li class="chapter-item expanded "><a href="webservice/controller.html"><strong aria-hidden="true">12.</strong> ðŸ’€ REST Controller Mk I </a></li><li class="chapter-item expanded "><a href="ops/restops/docs/controller.html"><strong aria-hidden="true">13.</strong> ðŸŽ‰ REST Controller Mk II </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ops/restops/docs/input-ports.html"><strong aria-hidden="true">13.1.</strong> REST Input Ports</a></li><li class="chapter-item expanded "><a href="ops/restops/docs/output-ports.html"><strong aria-hidden="true">13.2.</strong> REST Output Ports</a></li><li class="chapter-item expanded "><a href="ops/restops/docs/middleware.html"><strong aria-hidden="true">13.3.</strong> Middleware</a></li></ol></li><li class="chapter-item expanded "><a href="sqldb/repository.html"><strong aria-hidden="true">14.</strong> ðŸ’€ CRUD Repository </a></li><li class="chapter-item expanded "><a href="sqldb/docs/new_repositories_typed.html"><strong aria-hidden="true">15.</strong> ðŸŽ‰Typed Repository</a></li><li class="chapter-item expanded "><a href="sqldb/docs/new_repositories_goqu.html"><strong aria-hidden="true">16.</strong> ðŸŽ‰Goqu Repository</a></li><li class="chapter-item expanded "><a href="sqldb/docs/new_repositories_sql.html"><strong aria-hidden="true">17.</strong> ðŸŽ‰SQL Repository</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Migration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Integration</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="integration/docs/openapi.html"><strong aria-hidden="true">19.1.</strong> ðŸŽ‰ OpenAPI Client </a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Streaming</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ops/streamops/index.html"><strong aria-hidden="true">20.1.</strong> ðŸŽ‰ Stream Operations </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ops/streamops/ports.html"><strong aria-hidden="true">20.1.1.</strong> Ports</a></li><li class="chapter-item expanded "><a href="ops/streamops/publishers.html"><strong aria-hidden="true">20.1.2.</strong> Publishers</a></li><li class="chapter-item expanded "><a href="ops/streamops/subscribers.html"><strong aria-hidden="true">20.1.3.</strong> Subscribers</a></li><li class="chapter-item expanded "><a href="schema/asyncapi/index.html"><strong aria-hidden="true">20.1.4.</strong> AsyncApi</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.2.</strong> Stream Providers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">20.2.1.</strong> Kafka</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.2.2.</strong> SQL</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.2.3.</strong> GoChannel</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.2.4.</strong> Redis</div></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Utilities</li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Audit Events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Auditable Models</div></li><li class="chapter-item expanded "><a href="cache/lru/index.html"><strong aria-hidden="true">23.</strong> Cache</a></li><li class="chapter-item expanded "><a href="certificate/index.html"><strong aria-hidden="true">24.</strong> Certificates and TLS</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Executing Commands</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Health Checks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Http Client</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Leader Election</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Pagination</div></li><li class="chapter-item expanded "><a href="resource/index.html"><strong aria-hidden="true">30.</strong> Resources</a></li><li class="chapter-item expanded "><a href="retry/index.html"><strong aria-hidden="true">31.</strong> Retry</a></li><li class="chapter-item expanded "><a href="sanitize/index.html"><strong aria-hidden="true">32.</strong> Sanitization</a></li><li class="chapter-item expanded "><a href="scheduled/index.html"><strong aria-hidden="true">33.</strong> Scheduled Tasks</a></li><li class="chapter-item expanded "><a href="transit/index.html"><strong aria-hidden="true">34.</strong> Transit Encryption</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> Validation</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Code Generation (skel)</li><li class="chapter-item expanded "><a href="skel/index.html"><strong aria-hidden="true">36.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="skel/docs/installation.html"><strong aria-hidden="true">37.</strong> Installation</a></li><li class="chapter-item expanded "><a href="skel/docs/usage.html"><strong aria-hidden="true">38.</strong> Usage</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">39.</strong> Projects</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="skel/docs/projects-generic.html"><strong aria-hidden="true">39.1.</strong> Generic Microservice</a></li><li class="chapter-item expanded "><a href="skel/docs/projects-beats.html"><strong aria-hidden="true">39.2.</strong> Probes (Beats)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">39.3.</strong> Service Pack Microservice</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">39.4.</strong> Service Pack UI</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">40.</strong> Continuous Integration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">41.</strong> Web Services</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">41.1.</strong> Domains</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">41.2.</strong> OpenAPI</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">42.</strong> Stream Services</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="skel/asyncapi/channels.html"><strong aria-hidden="true">42.1.</strong> Channels</a></li><li class="chapter-item expanded "><a href="skel/asyncapi/spec.html"><strong aria-hidden="true">42.2.</strong> AsyncAPI</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">43.</strong> Deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">43.1.</strong> Kubernetes</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="skel/docs/skaffold.html"><strong aria-hidden="true">43.1.1.</strong> Skaffold</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Builds</li><li class="chapter-item expanded "><div><strong aria-hidden="true">44.</strong> Introduction</div></li><li class="chapter-item expanded "><a href="build/docs/usage-make.html"><strong aria-hidden="true">45.</strong> Makefile Usage</a></li><li class="chapter-item expanded "><a href="build/docs/usage-build.html"><strong aria-hidden="true">46.</strong> Build Usage</a></li><li class="chapter-item expanded "><a href="build/docs/config.html"><strong aria-hidden="true">47.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="build/docs/targets.html"><strong aria-hidden="true">48.</strong> Build Targets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build/docs/targets-project.html"><strong aria-hidden="true">48.1.</strong> Project Maintenance</a></li><li class="chapter-item expanded "><a href="build/docs/targets-development.html"><strong aria-hidden="true">48.2.</strong> Development</a></li><li class="chapter-item expanded "><a href="build/docs/targets-artifacts.html"><strong aria-hidden="true">48.3.</strong> Artifacts</a></li><li class="chapter-item expanded "><a href="build/docs/targets-verification.html"><strong aria-hidden="true">48.4.</strong> Verification</a></li><li class="chapter-item expanded "><a href="build/docs/targets-publishing.html"><strong aria-hidden="true">48.5.</strong> Publishing</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Continuous Integration</li><li class="chapter-item expanded "><a href="checks/index.html"><strong aria-hidden="true">49.</strong> Checks ðŸŽ‰</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">50.</strong> Jenkins</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">For Developers of go-msx</li><li class="chapter-item expanded "><div><strong aria-hidden="true">51.</strong> Introduction</div></li><li class="chapter-item expanded "><a href="CONTRIBUTING.html"><strong aria-hidden="true">52.</strong> Contributing</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">53.</strong> skel: Code Generation</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="skel/docs/sequence.html"><strong aria-hidden="true">53.1.</strong> Execution Sequence</a></li><li class="chapter-item expanded "><a href="skel/docs/templating.html"><strong aria-hidden="true">53.2.</strong> Making templates</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">go-msx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-msx"><a class="header" href="#go-msx">go-msx</a></h1>
<p>go-msx is a Go library for microservices and tools interacting with MSX. </p>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>Support for go-msx and related projects is available on the <a href="https://ciscovms.slack.com/messages/go-msx">#go-msx</a>
channel on the <a href="https://ciscovms.slack.com/">MSX slack workspace</a>.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>Currently this library and tools are in a pre-alpha state.  They are subject to
backwards-incompatible changes at <em>any</em> time.  After reaching the first stable release (v1.0.0),
<a href="https://semver.org/">SemVer</a> will be used per industry and golang best practices.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>
<p>Go 1.18+</p>
<ul>
<li>
<p>Ensure your GOPATH is correctly set and referenced in your PATH.  For example:</p>
<pre><code class="language-bash">export GOPATH=~/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
</li>
<li>
<p>Be sure to set your Go proxy settings correctly.  For example:</p>
<pre><code class="language-bash">go env -w GOPRIVATE=cto-github.cisco.com/NFV-BU
</code></pre>
</li>
</ul>
</li>
<li>
<p>Git SSH configuration for <code>cto-github.cisco.com</code></p>
<ul>
<li>
<p>Ensure you have a registered SSH key referenced in your <code>~/.ssh/config</code>:</p>
<pre><code>Host cto-github.cisco.com
      HostName cto-github.cisco.com
      User git
      IdentityFile ~/.ssh/github.key
</code></pre>
<p>Note that this key must be registered via the <a href="https://cto-github.cisco.com/settings/keys">Github UI</a>.</p>
</li>
<li>
<p>Ensure you have SSH protocol override for git HTTPS urls to our github in your <code>~/.gitconfig</code>:</p>
<pre><code>[url &quot;ssh://git@cto-github.cisco.com/&quot;]
        insteadOf = https://cto-github.cisco.com/
</code></pre>
</li>
</ul>
</li>
<li>
<p>Skel tool for code generation</p>
<ul>
<li>
<p>Check out go-msx into your local workspace:</p>
<pre><code class="language-bash">mkdir -p $HOME/msx &amp;&amp; cd $HOME/msx
git clone git@cto-github.cisco.com:NFV-BU/go-msx.git
cd go-msx
go mod download
</code></pre>
</li>
<li>
<p>Install <code>skel</code>:</p>
<pre><code class="language-bash">make install-skel
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<ul>
<li>
<p>To continue working on an existing go-msx project:</p>
<ul>
<li>Return to the original project README instructions
and continue.</li>
</ul>
</li>
<li>
<p>To add go-msx to an existing module-enabled go project:</p>
<pre><code class="language-bash">go get -u cto-github.cisco.com/NFV-BU/go-msx
</code></pre>
</li>
<li>
<p>To create a new go-msx microservice skeleton project:</p>
<pre><code class="language-bash">cd $HOME/msx
skel
</code></pre>
</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Please visit our <a href="https://cto-github.cisco.com/pages/NFV-BU/go-msx">internal site</a>
or <a href="https://mcrawfo2.github.io/go-msx/">public site</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright Â© 2019-2022, Cisco Systems Inc.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-overview"><a class="header" href="#modules-overview">Modules Overview</a></h1>
<p>go-msx is composed of a number of layers and modules.</p>
<p><img src="go-msx-modules.svg" alt="Modules Diagram" /></p>
<h2 id="application"><a class="header" href="#application">Application</a></h2>
<ul>
<li><code>app</code>: Application lifecycle</li>
<li><code>background</code>: Application background errors</li>
</ul>
<h2 id="platform"><a class="header" href="#platform">Platform</a></h2>
<ul>
<li><code>restops</code>: HTTP REST endpoints</li>
<li><code>streamops</code>: Stream channels</li>
<li><code>scheduled</code>: Scheduled tasks</li>
<li><code>audit</code>: Updating model audit fields and logging auditable events</li>
<li><code>exec</code>: Subprocess execution</li>
<li><code>httpclient</code>: HTTP client</li>
<li><code>rbac</code>: Role-based Access control</li>
<li><code>security</code>: Attribute-based Access control</li>
<li><code>retry</code>: Reliability</li>
<li><code>sanitize</code>: Input/Output sanitization</li>
<li><code>transit</code>: Transit encryption</li>
<li><code>validate</code>: Data validation</li>
<li><code>migrate</code>: Database migration
<ul>
<li><code>/sqldb/migrate</code>: SQL database migration</li>
</ul>
</li>
<li><code>populate</code>: API population</li>
</ul>
<h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<ul>
<li><code>discovery</code>: Register and Locate microservices
<ul>
<li><code>consulprovider</code>: Consul discovery provider </li>
</ul>
</li>
<li><code>stream</code>: Communicate using streams</li>
<li><code>webservice</code>: REST web server
<ul>
<li><code>adminprovider</code>: Admin actuator</li>
<li><code>aliveprovider</code>: Liveness actuator</li>
<li><code>apilistprovider</code>: API list documentation</li>
<li><code>asyncapiprovider</code>: AsyncApi documentation</li>
<li><code>authprovider</code>: Authentication</li>
<li><code>debugprovider</code>: Debug profiling</li>
<li><code>envprovider</code>: Configuration actuator</li>
<li><code>healthprovider</code>: Health actuator</li>
<li><code>idempotency</code>: Idempotency-Key filter</li>
<li><code>infoprovider</code>: Info actuator</li>
<li><code>loggersprovider</code>: Logging actuator</li>
<li><code>maintenanceprovider</code>: Maintenance actuator</li>
<li><code>metricsprovider</code>: Metrics actuator</li>
<li><code>prometheusprovider</code>: Prometheus stats</li>
<li><code>swaggerprovider</code>: Swagger documentation</li>
</ul>
</li>
<li><code>cli</code>: Command line interaction</li>
<li><code>health</code>: Health checks
<ul>
<li><code>consulcheck</code>: Consul health check</li>
<li><code>kafkacheck</code>: Kafka health check</li>
<li><code>redischeck</code>: Redis health check</li>
<li><code>sqldbcheck</code>: SQL health check</li>
<li><code>vaultcheck</code>: Vault health check</li>
</ul>
</li>
<li><code>integration</code>: REST API client</li>
<li><code>cache</code>: Caching
<ul>
<li><code>lru</code>: In-Memory cache provider</li>
<li><code>/redis/cache</code>: Redis cache provider</li>
</ul>
</li>
<li><code>operations</code>: Operations support</li>
<li><code>schema</code>: Schema documentation
<ul>
<li><code>asyncapi</code>: AsyncApi schema documentation</li>
<li><code>js</code>: JSON schema documentation</li>
<li><code>openapi</code>: OpenApi schema documentation</li>
<li><code>swagger</code>: Swagger schema documentation</li>
</ul>
</li>
<li><code>leader</code>: Leader election
<ul>
<li><code>consulprovider</code>: Consul leader provider</li>
</ul>
</li>
<li><code>certificate</code>: Certificate management</li>
</ul>
<h1 id="infrastructure"><a class="header" href="#infrastructure">Infrastructure</a></h1>
<ul>
<li><code>consul</code>: Consul driver</li>
<li><code>vault</code>: Vault driver</li>
<li><code>redis</code>: Redis driver</li>
<li><code>sqldb</code>: SQL database driver</li>
<li><code>kafka</code>: Kafka driver</li>
<li><code>trace/datadog</code>: Datadog tracing</li>
<li><code>trace/jaeger</code>: Jaeger tracing</li>
</ul>
<h1 id="core"><a class="header" href="#core">Core</a></h1>
<ul>
<li><code>config</code>: Configuration</li>
<li><code>log</code>: Logging</li>
<li><code>trace</code>: Tracing</li>
<li><code>stats</code>: Statistics</li>
<li><code>fs</code>: Filesystems</li>
<li><code>resources</code>: Resources</li>
<li><code>types</code>: Reusable data types</li>
</ul>
<h1 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h1>
<ul>
<li><code>build</code>: Build execution</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-logging-module"><a class="header" href="#msx-logging-module">MSX Logging Module</a></h1>
<p>MSX logging is an extension of the popular <code>logrus</code> logging library, to include:</p>
<ul>
<li>Log names</li>
<li>Level-specific loggers</li>
<li>Improved context handling</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>After importing the MSX log package, you can use the default named logger <code>msx</code> simply:</p>
<pre><code class="language-go">import &quot;cto-github.cisco.com/NFV-BU/go-msx/log&quot;

var logger = log.StandardLogger()

func main() {
    var action = &quot;started&quot;
    logger.Infof(&quot;Something happened: %s&quot;, action) 
}
</code></pre>
<p>To use a logger with a custom name:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;alert.api&quot;)
</code></pre>
<p>To create a logger named after the current module:</p>
<pre><code class="language-go">var logger = log.NewPackageLogger()
</code></pre>
<p>To create a levelled logger, which outputs print at the defined log level:</p>
<pre><code class="language-go">debugLogger := logger.Level(log.DebugLevel)
debugLogger.Printf(&quot;Some template: %s&quot;, &quot;inserted&quot;)
</code></pre>
<p>To record a golang <code>error</code> object:</p>
<pre><code class="language-go">func DeployResource(data []byte) {
    var body ResourceDeployment
    if err := json.Unmarshal(data, &amp;body); err != nil {
        logger.
            WithError(err).
            Error(&quot;Failed to parse Resource Deployment request&quot;)
    }
}
</code></pre>
<p>To use the log context that was embedded in a Context object:</p>
<pre><code class="language-go">func HandleRequest(ctx context.Context) {
    requestLogger := logger.WithContext(ctx)
    ...
}
</code></pre>
<p>To add one-time custom diagnostic fields:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;tenant&quot;)

func HandleGetTenantRequest(tenantId string) {
    logger.
        WithExtendedField(&quot;tenantId&quot;, tenantId).
        Debug(&quot;Tenant retrieval requested&quot;)
}
</code></pre>
<p>To create a sub-logger with custom diagnostic fields:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;services.tenant&quot;)

func HandleGetTenantRequest(tenantId string) {
    requestLogger := logger.WithExtendedField(&quot;tenantId&quot;, tenantId)
    requestLogger.Debugf(&quot;some message&quot;)
}
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="logging-levels"><a class="header" href="#logging-levels">Logging Levels</a></h3>
<p>MSX Logging defines the following log levels:</p>
<ul>
<li>Trace</li>
<li>Debug</li>
<li>Info</li>
<li>Warn</li>
<li>Error</li>
<li>Panic</li>
<li>Fatal</li>
</ul>
<p>A logging level filter can be set globally:</p>
<pre><code class="language-go">log.SetLevel(log.WarnLevelName)
</code></pre>
<p>This will ensure all loggers not configured at a more strict level only output messages with a level of <code>WARN</code> or above.</p>
<p>An individual logger (and its sub-loggers) can be set to a minimum level:</p>
<pre><code class="language-go">logger = log.NewLogger(&quot;msx.beats&quot;)
logger.SetLevel(log.LevelByName(log.InfoLevelName)))
</code></pre>
<p>Configuration (eg. command line options) can be used to set a logger minimum level:</p>
<pre><code class="language-bash">myapp --logger.msx.beats=debug
</code></pre>
<p>This will set the minimum level of the <code>msx.beats</code> logger tree to <code>DEBUG</code> after
the application configuration has been loaded.</p>
<h3 id="output-format"><a class="header" href="#output-format">Output Format</a></h3>
<p>Output can be switched to JSON formatting:</p>
<pre><code class="language-go">log.SetFormat(log.LogFormatJson)
</code></pre>
<p>And back to LogFmt formatting:</p>
<pre><code class="language-go">log.SetFormat(log.LogFormatLogFmt)
</code></pre>
<p>By default, all output is sent to standard output, with high-resolution
timestamps. See <a href="log/init.go">init.go</a> for specifics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>Go has a built-in <code>error</code> interface to be implemented by error
models.</p>
<p>go-msx has chosen to use the <code>github.com/pkg/errors</code>
module to implement errors.  This custom error module enables collecting
stack traces, critical for logging and debugging of errors.</p>
<p>When instantiating or wrapping an error,
use this package instead of the standard library <code>errors</code> package.</p>
<pre><code class="language-go">
import (
	&quot;context&quot;
	&quot;github.com/pkg/errors&quot;
)

// Create a globally visible error
var MyStaticError = errors.New(&quot;Static error occurred&quot;)
var MyOtherError = errors.New(&quot;Other error occurred&quot;)
	
// Return the global error
func mine(ctx context.Context) error {
  return MyStaticError
}

// Wrap the error into your own domain
func yours(ctx context.Context) error {
  return errors.Wrap(mine(ctx), &quot;Something bad happened&quot;)
}

func callYours(ctx context.Context) error {
  err := yours(ctx)
  if errors.Is(err, MyStaticError) {
    // Special handling for this error type		
  } else {
    // General hanlding for any other error types
    return err
  }
  return nil
}
</code></pre>
<p>The above example shows how to create a global error, and how to re-contextualize (wrap)
inside the parent.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Composite errors implement the <code>CompositeError</code> interface:</p>
<pre><code class="language-go">type CompositeError interface {
  Errors() interface{}
}
</code></pre>
<p>go-msx provides two composite error models: <code>ErrorMap</code> and <code>ErrorList</code>.
Each of these represents a set of errors.</p>
<ul>
<li>
<p><code>ErrorMap</code> : Represents a set of key-error pairs, intended to map to sub-parts
of a structured parent component.</p>
<pre><code class="language-go">return types.ErrorMap{
    &quot;element1&quot;: validation.Validate(&amp;element1, validation.Required)
    &quot;element2&quot;: validation.Validate(&amp;element2, validation.MinLength(1))
}
</code></pre>
</li>
<li>
<p><code>ErrorList</code> : Represents a series of error instances (or nils), intended to map
to elements in a parent sequence.</p>
<pre><code class="language-go">return types.ErrorList{
    validation.Validate(&amp;parent[0], validation.Required)
    validation.Validate(&amp;parent[1], validation.MinLength(1))
}
</code></pre>
</li>
</ul>
<p>The above error models also implement <code>Filterable</code>:</p>
<pre><code class="language-go">type Filterable interface {
  Filter() error
}
</code></pre>
<p>This allows the composite error to collect non-error (nil) values, which will
be removed from the return value of <code>Filter()</code>.  This feature is used by the 
validate package during DTO validation.</p>
<h2 id="log-customization"><a class="header" href="#log-customization">Log Customization</a></h2>
<p>To enable attaching custom log fields from your error, the logging
subsystem checks if your error implements the LogFielder interface:</p>
<pre><code class="language-go">type LogFielder interface {
  LogFields() map[string]any
}
</code></pre>
<p>Any fields returned by the <code>LogFields()</code> function will be added
as log fields if the error is output to the log via <code>WithError()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-configuration-module"><a class="header" href="#msx-configuration-module">MSX Configuration Module</a></h1>
<p>MSX configuration is a spring-compatible dynamic configuration library.  It includes support for:</p>
<ul>
<li>remote configuration stores</li>
<li>dynamic configuration updates</li>
<li>JSON, JSON5, YAML, INI and Properties files </li>
<li>key normalization </li>
<li>structure population</li>
</ul>
<h2 id="model"><a class="header" href="#model">Model</a></h2>
<p>MSX Configuration has three main components: <strong>providers</strong>, <strong>settings</strong>, and the <strong>config</strong> object. </p>
<ul>
<li><strong>Providers</strong> load settings for your application. This could be from a file, environment variables, or some other source of configuration.</li>
<li><strong>Settings</strong> represent the configuration options for your application. Settings are represented as key/value pairs. </li>
<li><strong>Config</strong> holds all of the providers and loaded settings. This object allows you to load, watch, retrieve, apply and convert your settings.</li>
</ul>
<p>Each provider combines its contents together into a single keyspace; these are then superposed (like a &quot;1000-layer lasagna&quot;) in order to produce a final combined keyspace and key/value mapping.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h3>
<p>When using MSX Configuration inside the MSX Application context, you can retrieve the configuration object from the <code>ctx context.Context</code>:</p>
<pre><code class="language-go">cfg := config.MustFromContext(ctx)
</code></pre>
<p>When using MSX Configuration outside of the MSX Application context, you can instantiate your own providers.  For example, to consume the environment variables from the current process:</p>
<pre><code class="language-go">environmentProvider := config.NewEnvironment(&quot;env&quot;)
cfg := config.NewConfig(environmentProvider)
</code></pre>
<h3 id="value-retrieval"><a class="header" href="#value-retrieval">Value Retrieval</a></h3>
<p>Using one of the above <code>cfg</code> objects, you can retrieve the user's home directory from the <code>HOME</code> environment variable.  Note that all config keys are normalized to be lowercase, no hyphens, period-separated.  This means the <code>HOME</code> environment variable will be mapped to <code>home</code>:</p>
<pre><code class="language-go">homePath, err := cfg.String(&quot;home&quot;)
</code></pre>
<p>The <code>cfg</code> object presents a number of functions to return a strongly-typed value:</p>
<ul>
<li><code>String(key string)</code></li>
<li><code>Int(key string)</code></li>
<li><code>Float(key string)</code></li>
<li><code>Bool(key string)</code></li>
</ul>
<p>These functions will look up the specified key in the configuration, and if found, will attempt to convert the value to the specified type.  If the key is not found or configuration has not yet been loaded, an appropriate error will be returned.</p>
<p>If you wish to use an alternative (default) value in case the lookup fails, you can use the <code>Or</code> functions:</p>
<ul>
<li><code>StringOr(key string, other string)</code></li>
<li><code>Int(key string, other int)</code></li>
<li><code>Float(key string, other float)</code></li>
<li><code>Bool(key string, other bool)</code></li>
</ul>
<p>The specified <code>other</code> value will be returned if the config has been loaded, but lookup fails:</p>
<pre><code class="language-go">buildPath, err := cfg.StringOr(&quot;build.path&quot;, &quot;./build&quot;)
</code></pre>
<h3 id="structure-population"><a class="header" href="#structure-population">Structure Population</a></h3>
<p>You can also populate appropriately defined structures:</p>
<pre><code class="language-go">type ConnectionConfig struct {
    Name string
    Skipped bool `config:&quot;-&quot;`
    AnotherName int `config:&quot;somethingelse&quot;`
}

var connectionConfig ConnectionConfig
err := cfg.Populate(&amp;connectionConfig, &quot;some.connection&quot;)
</code></pre>
<p>Each structure field is treated a little differently based on the contents/existence of the <code>config</code> struct tag:</p>
<ul>
<li><code>Name</code>: populated from <code>some.connection.name</code> (default behaviour)</li>
<li><code>Skipped</code>: not populated due to the <code>config:&quot;-&quot;</code> (omit when source name is a hyphen)</li>
<li><code>AnotherName</code>: populated from <code>some.connection.somethingelse</code> (overridden field name)</li>
</ul>
<h2 id="spring-compatibility"><a class="header" href="#spring-compatibility">Spring Compatibility</a></h2>
<p>One of the primary goals for MSX Configuration is close compatibility with Spring-style configuration.
Several known incompatibilities and limitations currently exist:</p>
<ol>
<li>Key Normalization
<ul>
<li>Configuration keys in MSX Configuration are simply normalized to be lowercase, no hyphens, period-separated. As of Spring 2.0, configuration keys are expected to be snake-case, period-separated. MSX Configuration cannot distinguish between the <code>app.some-data</code> and <code>app.somedata</code> keys, and normalizes them both to <code>app.somedata</code>.</li>
</ul>
</li>
<li>Arbitrary Population
<ul>
<li>MSX Configuration currently supports <code>@ConfigurationProperties</code> style structure population.  As a consequence, all data used to populate a structure must be direct descendants of the key used to populate the structure.  We intend to support arbitrary key specification for structures in the future.</li>
</ul>
</li>
</ol>
<h2 id="built-in-providers"><a class="header" href="#built-in-providers">Built-In Providers</a></h2>
<p>MSX Configuration has many built-in providers, allowing the application to unify configuration from a wide variety of sources:</p>
<ul>
<li><code>INIFile</code> - Loads settings from a <code>.ini</code> file</li>
<li><code>JSONFile</code>  - Loads settings from a <code>.json</code> or <code>.json5</code> file</li>
<li><code>YAMLFile</code> - Loads settings from a <code>.yaml</code> or <code>.yml</code> file</li>
<li><code>TOMLFile</code> - Loads settings from a <code>.toml</code> file</li>
<li><code>PropertiesFile</code> - Loads settings from a <code>.properties</code> file</li>
<li><code>CobraProvider</code> - Loads settings from a Cobra command context</li>
<li><code>PFlagProvider</code> - Loads settings from PFlag flagset</li>
<li><code>GoFlagProvider</code> - Loads settings from a go flag flagset</li>
<li><code>ConsulProvider</code> - Loads settings from Consul</li>
<li><code>VaultProvider</code> - Loads settings from Vault</li>
<li><code>Environment</code> - Loads settings from environment variables </li>
<li><code>Static</code> - Loads settings from an in-memory map</li>
</ul>
<h3 id="helpers"><a class="header" href="#helpers">Helpers</a></h3>
<p>Along with the above providers, there are some wrappers for managing config lifecycle:</p>
<ul>
<li><code>CachedLoader</code> - Caches settings in memory until flushed by <code>Invalidate()</code></li>
<li><code>OnceLoader</code> - Caches settings in memory permanently</li>
<li><code>Resolver</code> - Remaps settings from one key to another</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consul-configuration-provider"><a class="header" href="#consul-configuration-provider">Consul Configuration Provider</a></h1>
<p>The Consul config provider reads settings from the KV version 1 consul plugin.
It currently supports two separate read paths: default and service-specific.
These read paths are expected to exist directly under the KV mount point.</p>
<p>The provider will, by default, load KV settings from the following locations:</p>
<ul>
<li><code>userviceconfiguration/defaultapplication</code> - default settings</li>
<li><code>userviceconfiguration/${info.app.name}</code> - service-specific settings</li>
</ul>
<h2 id="provider-configuration"><a class="header" href="#provider-configuration">Provider Configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>spring.cloud.consul.config.enabled</td><td>false</td><td>Optional</td><td>Enable loading configuration from consul KV</td></tr>
<tr><td>spring.cloud.consul.config.disconnected</td><td>false</td><td>Optional</td><td>Activate &quot;disconnected&quot; mode for CLI commands</td></tr>
<tr><td>spring.cloud.consul.config.prefix</td><td>userviceconfiguration</td><td>Optional</td><td>Consul KV mount point</td></tr>
<tr><td>spring.cloud.consul.config.default-context</td><td>defaultapplication</td><td>Optional</td><td>KV folder path under mount point containing global settings</td></tr>
<tr><td>spring.cloud.consul.config.pool</td><td>false</td><td>Optional</td><td>Pool consul connections</td></tr>
<tr><td>spring.cloud.consul.config.delay</td><td>3s</td><td>Optional</td><td>Retry delay after KV setting retrieval failure</td></tr>
<tr><td>spring.cloud.consul.config.required</td><td><code>- ${spring.cloud.consul.config.prefix}/${spring.cloud.consul.config.default-context}</code></td><td>Optional</td><td>KV settings paths that <em>must</em> return KV values</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="msx-application-module"><a class="header" href="#msx-application-module">MSX Application Module</a></h1>
<p>MSX Application is a simple state machine for managing application lifecycle.  It installs observers to configure and instantiate the standard components for use with MSX applications.  This includes listeners for external events to advance the state machine (e.g. POSIX signals, configuration changes).</p>
<h2 id="lifecycle-events"><a class="header" href="#lifecycle-events">Lifecycle Events</a></h2>
<p>MSX Application defines various lifecycle events:</p>
<ul>
<li><code>app.EventCommand</code> - mode selection based on CLI sub-commands</li>
<li><code>app.EventInit</code> - pre-configure application </li>
<li><code>app.EventConfigure</code> - application and component configuration </li>
<li><code>app.EventStart</code> - start services for consumers</li>
<li><code>app.EventReady</code> - application fully initialized and ready to service requests</li>
<li><code>app.EventRefresh</code> - update configuration after change</li>
<li><code>app.EventStop</code> - stop services for consumers</li>
<li><code>app.EventFinalize</code> - pre-termination cleanup</li>
</ul>
<p>Each event (except <code>app.EventCommand</code>) proceeds with three phases:</p>
<ul>
<li><code>app.PhaseBefore</code> - early</li>
<li><code>app.PhaseDuring</code> - normal</li>
<li><code>app.PhaseAfter</code> - late</li>
</ul>
<p>The <code>app.EventCommand</code> event will be execute with the <code>phase</code> containing the command being executed.  The following commands are pre-defined:</p>
<ul>
<li><code>app.CommandRoot</code> - Root (default)</li>
<li><code>app.CommandMigrate</code> - Migrate</li>
<li><code>app.CommandPopulate</code> - Populate</li>
</ul>
<h3 id="event-observers"><a class="header" href="#event-observers">Event Observers</a></h3>
<p>When a lifecycle event phase is occurring, the MSX Application will call each of the <code>Observer</code>s registered for the event phase.  These callbacks can be registered during any previous lifecycle event callback or during your module <code>init()</code>.</p>
<p>For example, to call the <code>addWebService</code> observer during <code>start.before</code> for all commands:</p>
<pre><code class="language-go">func init() {
    app.OnEvent(app.EventStart, app.PhaseBefore, addWebService)
}
</code></pre>
<p>To see an example showing command-specific event observers, see <a href="app/index.html#Commanding">Commanding</a>, below.</p>
<h3 id="short-circuiting"><a class="header" href="#short-circuiting">Short-Circuiting</a></h3>
<p>Sometimes an application is not able to correctly execute a lifecycle phase, or receives an external interruption.  This will result in a short-circuit of the lifecycle.  If an error is returned from one of the observers in the following phases, the lifecycle will move to the specified phase:</p>
<ul>
<li><code>app.EventInit</code> =&gt; <code>app.EventFinalize</code></li>
<li><code>app.EventConfigure</code> =&gt; <code>app.EventFinalize</code></li>
<li><code>app.EventStart</code> =&gt; <code>app.EventStop</code></li>
<li><code>app.EventReady</code> =&gt; <code>app.EventStop</code></li>
</ul>
<h2 id="application-observers"><a class="header" href="#application-observers">Application Observers</a></h2>
<h3 id="command"><a class="header" href="#command">Command</a></h3>
<p>The <code>app.EventCommand</code> events are the first events fired during startup.  They provide the opportunity to execute custom logic and register event observers specific to the command.</p>
<p>As above, the <code>app.EventCommand</code> event will be executed with the phase containing the command being executed.  For example the phase could be one of the default commands:</p>
<ul>
<li>Root (<code>app.CommandRoot</code>)</li>
<li>Migrate (<code>app.CommandMigrate</code>)</li>
<li>Populate (<code>app.CommandPopulate</code>)</li>
</ul>
<p>To add a new command:</p>
<pre><code class="language-go">func main() {
    if _, err := app.AddCommand(&quot;token&quot;, &quot;Create OAuth2 token&quot;, renew, app.Noop); err != nil {
        cli.Fatal(err)
    }
}
</code></pre>
<p>To configure event observers in response to a specific command being executed:</p>
<pre><code class="language-go">func init() {
    app.OnEvent(app.EventCommand, app.CommandRoot, func(ctx context.Context) error {
        app.OnEvent(app.EventStart, app.PhaseBefore, addWebService)
        return nil
    })
}
</code></pre>
<h3 id="init"><a class="header" href="#init">Init</a></h3>
<p>The <code>app.EventInit</code> events are fired second, after the <code>app.EventCommand</code> events.</p>
<p>Observers attached to the <code>app.EventInit</code> events should be restricted to modifying the application environment.  This includes registering custom config providers or custom context injectors.</p>
<h3 id="configure"><a class="header" href="#configure">Configure</a></h3>
<p>The <code>app.EventConfigure</code> events are fired third during startup, after the <code>app.EventInit</code> events.</p>
<p>By default, the application is configured:</p>
<ul>
<li><code>app.PhaseBefore</code>
<ul>
<li>Register remote config providers</li>
</ul>
</li>
<li><code>app.PhaseDuring</code>
<ul>
<li><a href="app/index.html#configuration-loading">Load configuration</a></li>
</ul>
</li>
<li><code>app.PhaseAfter</code>
<ul>
<li>HTTP Client</li>
<li>Consul connection pool</li>
<li>Vault connection pool</li>
<li>Cassandra connection pool</li>
<li>Redis connection pool</li>
<li>Kafka connection pool</li>
<li>Web server</li>
<li>Create Cassandra Keyspace</li>
</ul>
</li>
</ul>
<p>Typically, user applications will not register new event handlers for the <code>app.EventConfigure</code> events.</p>
<h3 id="start"><a class="header" href="#start">Start</a></h3>
<p>The <code>app.EventStart</code> events are fired fourth during startup, after the <code>app.EventConfigure</code> events.</p>
<p>By default, application infrastructure is connected:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Authentication Providers</li>
<li>Spring Actuators</li>
<li>Swagger</li>
<li>Prometheus Actuator</li>
<li>Stats Pusher</li>
</ul>
</li>
<li><code>app.PhaseAfter</code>:
<ul>
<li>Health logging</li>
<li>Stream Router</li>
<li>Web Server</li>
<li>Config Watcher</li>
</ul>
</li>
</ul>
<p>Custom application startup code is expected to run inside the <code>app.PhaseDuring</code> phase.  This would include starting any long-running services or scheduling background tasks.</p>
<h3 id="ready"><a class="header" href="#ready">Ready</a></h3>
<p>The <code>app.EventReady</code> events are fired fifth during startup, after the <code>app.EventStart</code> events.</p>
<p>By default, application ready observers are executed:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Service Registration (consul)</li>
</ul>
</li>
<li><code>app.PhaseAfter</code>:
<ul>
<li>Command Execution (sub-commands)</li>
</ul>
</li>
</ul>
<h3 id="refresh"><a class="header" href="#refresh">Refresh</a></h3>
<p><em>TBD</em></p>
<h3 id="stop"><a class="header" href="#stop">Stop</a></h3>
<p>The <code>app.EventStop</code> events are fired first during shutdown.</p>
<p>By default, application services are stopped and infrastructure and disconnected:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Service De-Registration (consul)</li>
<li>Health logging</li>
<li>Stream router</li>
<li>Web Server</li>
<li>Stats Pusher</li>
</ul>
</li>
</ul>
<p>Any custom application code running in the background should be shutdown during <code>app.PhaseDuring</code>.</p>
<h3 id="finalize"><a class="header" href="#finalize">Finalize</a></h3>
<p>The <code>app.EventFinal</code> events are fired last during shutdown.</p>
<p>By default, tracing is stopped during <code>app.PhaseAfter</code> to allow trace collection to include <code>app.EventStop</code>.</p>
<h2 id="configuration-loading"><a class="header" href="#configuration-loading">Configuration Loading</a></h2>
<p>In response to the <code>app.EventConfigure</code> event, MSX Application combines all registered sources of configuration.  This occurs in three phases:</p>
<ul>
<li><strong>Phase 1</strong> - In-Memory
<ul>
<li>Application Static Defaults</li>
<li>Environment Variables</li>
<li>Application Runtime Overrides</li>
<li>Command Line</li>
</ul>
</li>
<li><strong>Phase 2</strong> - Filesystem
<ul>
<li>Defaults Files</li>
<li>Bootstrap Files</li>
<li>Application Files</li>
<li>Profile Files </li>
<li>Build Files</li>
</ul>
</li>
<li><strong>Phase 3</strong> - Remote
<ul>
<li>Consul</li>
<li>Vault</li>
</ul>
</li>
</ul>
<p>Note that this loading order is not the same as the order of precendence for calculating values:</p>
<ul>
<li>Application Static Defaults</li>
<li>Defaults Files</li>
<li>Bootstrap Files</li>
<li>Application Files</li>
<li>Build Files</li>
<li>Consul</li>
<li>Vault</li>
<li>Profile Files</li>
<li>Environment Variables</li>
<li>Command Line</li>
<li>Application Runtime Overrides</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-dependencies"><a class="header" href="#msx-dependencies">MSX Dependencies</a></h1>
<p>In large applications, inter-object dependency management becomes more challenging.  Within the go standard library, the <a href="https://blog.golang.org/context"><code>Context</code></a> object is provided to share dependencies and cancellation.  This simplifies writing unit tests, since dependencies can be injected via the context.</p>
<p>MSX Application provides a <code>Context</code> object to event <code>Observer</code>s so they may inject new dependencies for their subsystems.  The context object also carries Trace information for logging and trace publishing.</p>
<p>By default, the following dependencies are added to the MSX Application context:</p>
<ul>
<li>Configuration</li>
<li>Cockroach client pool</li>
<li>Consul client pool</li>
<li>Vault client pool</li>
<li>Redis client pool</li>
<li>Kafka client pool</li>
<li>Http client factory</li>
</ul>
<p>During <code>migrate</code> execution, the Migration Manifest is also available from the context.</p>
<h2 id="accessing-dependencies"><a class="header" href="#accessing-dependencies">Accessing Dependencies</a></h2>
<p>Each substitutable component in go-msx requires a context accessor to allow injecting and
inspecting overrides:</p>
<pre><code class="language-go">type contextKeyNamed string

func ContextDomainService() types.ContextAccessor[DomainService] {
	return types.NewContextAccessor[DomainService](contextKeyNamed(&quot;DomainService&quot;))
}
</code></pre>
<p>Key to type safety is the external invisibility of the context key.  This is guaranteed
by defined a module-local type (<code>contextKey</code> or <code>contextKeyNamed</code>) and using an instance of it
to index the context inspection/injection.</p>
<p>To inject your custom dependency to the current context:</p>
<pre><code class="language-go">ctx = domain.ContextDomainService().Set(ctx, domainService)
</code></pre>
<p>To retrieve a dependency from the current context:</p>
<pre><code class="language-go">domainServiceApi := domain.ContextDomainService().Get(ctx)
</code></pre>
<p>or:</p>
<pre><code class="language-go">domainServiceApi, ok := domain.ContextDomainService().TryGet(ctx)
</code></pre>
<h2 id="logging-and-tracing"><a class="header" href="#logging-and-tracing">Logging and Tracing</a></h2>
<p>To apply logging and tracing fields from the current context:</p>
<pre><code class="language-go">myLogger.WithContext(ctx).Info(&quot;My log message&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-statistics"><a class="header" href="#msx-statistics">MSX Statistics</a></h1>
<p>MSX Statistics allows applications to monitor and record application metrics for display on dashboards and generation of application alarms.  We have chosen to support Prometheus and its OpenMetrics format to expose collected data.</p>
<h2 id="statistics-types"><a class="header" href="#statistics-types">Statistics Types</a></h2>
<p>MSX Statistics supports several base data collection types:</p>
<ul>
<li>
<p><strong>Counter</strong></p>
<p>A counter is an ever-increasing number. For example, &quot;Completed Requests&quot; will continuously increase throughout the lifetime of the application.  It is initialized to zero on application startup.</p>
</li>
<li>
<p><strong>Gauge</strong></p>
<p>A gauge is a metric that represents a single numerical value that can arbitrarily go up and down. For example, &quot;Active Requests&quot; increases when a new request arrives, and decreases when a request is fully serviced.</p>
</li>
<li>
<p><strong>Histogram</strong></p>
<p>A histogram samples observations (usually things like request durations or response sizes) and counts them in configurable buckets. It also provides a sum of all observed values.  For example, &quot;Query Duration&quot; has a range of time values (from 0 seconds and up).  These can be put into buckets to see what the 99th percentile Query Duration is (using the prometheus <code>histogram_quantile</code> function in the dashboard).</p>
</li>
</ul>
<p>If you wish to further group the data, you can use the Vector version of each of the above types.  For example, we can group a &quot;Request Duration Histogram&quot; by API endpoint, in order to see the distribution of request duration distributions for each endpoint separated from other endpoints.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="instantiation-1"><a class="header" href="#instantiation-1">Instantiation</a></h3>
<p>To start collecting a statistic, you must first initialize its collector.  This can be accomplished during module initialization by assigning the collector to a module-global variable:</p>
<pre><code class="language-go">const (
    statsSubsystemConsul               = &quot;consul&quot;
    statsHistogramConsulCallTime       = &quot;call_time&quot;
    statsGaugeConsulCalls              = &quot;calls&quot;
    statsCounterConsulCallErrors       = &quot;call_errors&quot;
    statsGaugeConsulRegisteredServices = &quot;registrations&quot;
)

var (
    // Collect the number of errors for each api
    countVecConsulCallErrors = stats.NewCounterVec(
        statsSubsystemConsul, 
        statsCounterConsulCallErrors, 
        &quot;api&quot;, &quot;param&quot;)

    // Collect the number of active requests for each api
    gaugeVecConsulCalls      = stats.NewGaugeVec(
        statsSubsystemConsul, 
        statsGaugeConsulCalls, 
        &quot;api&quot;, &quot;param&quot;)

    // Collect the distribution of call execution times for each api
    histVecConsulCallTime    = stats.NewHistogramVec(
        statsSubsystemConsul, 
        statsHistogramConsulCallTime, 
        nil, 
        &quot;api&quot;, &quot;param&quot;)
)
</code></pre>
<p>As you can see above, each of the collector constructors start with two required arguments:</p>
<ul>
<li>
<p><strong>Subsystem</strong></p>
<p>Identifies the application subsystem being monitored.  In this case, <code>consul</code>.</p>
</li>
<li>
<p><strong>Metric Name</strong></p>
<p>Identifies the individual metric dimension.  By convention, duration histograms end with <code>_time</code>, and counters are pluralized.</p>
</li>
</ul>
<p>The histogram (and histogram vector) constructors require an argument specifying the buckets and their upper limits.  To use the default buckets, pass <code>nil</code> for this argument.  The current default buckets are calculated by executing <code>prometheus.ExponentialBuckets(10, 2, 16)</code>: this evaluates to <code>[10, 20, 40, ..., 655360]</code>.  For more information about histograms, you can visit the <a href="https://prometheus.io/docs/practices/histograms/">Prometheus documentation</a>.</p>
<p>Vector constructors, as shown above, accept a final series of dimensions to be applied to each of the measurements.  In the example above, each of our vectors accepts the <code>api</code> and <code>param</code> groupings.  In the consul stats collector:</p>
<ul>
<li><code>api</code> identifies which Consul API endpoint is being called (by path)</li>
<li><code>param</code> identifies eg. the servicename for discovery</li>
</ul>
<h3 id="collection"><a class="header" href="#collection">Collection</a></h3>
<p>After initializing your collectors, you can start to measure your application as the relevant events occur.</p>
<p>A common pattern is define a wrapper function whose only purpose is to collect statistics.  In the Consul package, we can see an example of this:</p>
<pre><code class="language-go">func observeConsulCall(api, param string, fn func() error) (err error) {
    // Collect the start time of the call
    start := time.Now()
    // Increase the number of active calls
    gaugeVecConsulCalls.WithLabelValues(api, param).Inc()

    // Execute this code before returning, even in case of panic()
    defer func() {
        // Reduce the number of active calls
        gaugeVecConsulCalls.WithLabelValues(api, param).Dec()
        
        // Bucket the call duration in the histogram
        histVecConsulCallTime.WithLabelValues(api, param).Observe(
            float64(time.Since(start)) / float64(time.Millisecond))

        if err != nil {
            // Increase the error count if an error was returned from fn
            countVecConsulCallErrors.WithLabelValues(api, param).Inc()
        }
    }()

    // Call the wrapped function and intercept it's error return value
    err = fn()
    
    // Return the wrapped function's value, after the defer block
    return err
}
</code></pre>
<p>There are a few things to note here not covered in the inline comments:</p>
<ol>
<li>We directly pass <code>api</code> and <code>param</code> group values to each of the vectors from the wrapper using <code>.WithLabelValues()</code>.  These must be passed in the same order as in the constructor.</li>
<li>Time periods should be calculated as <code>float64</code> milliseconds.</li>
<li>Counters and Gauges can be incremented by <code>1.0</code> using the <code>.Inc()</code> method.</li>
<li>Gauges can be decremented by <code>1.0</code> using the <code>.Dec()</code> method.</li>
<li>Histograms can record an observation using the <code>.Observe()</code> method.</li>
</ol>
<h2 id="push-gateway"><a class="header" href="#push-gateway">Push Gateway</a></h2>
<p>By default, the MSX Statistics package expects the statistics to be polled by an external application.  If such a poller is not available, MSX Statistics can be configured to push
to an external Prometheus push gateway.</p>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>The following configuration settings can be specified to configure the stats pusher:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>stats.push.enabled</code></td><td>enable the stats pusher</td><td><code>false</code></td></tr>
<tr><td><code>stats.push.url</code></td><td>url to push stats too</td><td></td></tr>
<tr><td><code>stats.push.job-name</code></td><td>prometheus job name to send</td><td><code>go_msx</code></td></tr>
<tr><td><code>stats.push.frequency</code></td><td>duration between pushes</td><td><code>15s</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-tracing"><a class="header" href="#distributed-tracing">Distributed Tracing</a></h1>
<p>MSX Distributed Tracing allows the collection of an operational flow graph. Based
on <a href="https://opentracing.io/docs/overview/">OpenTracing</a>, tracing helps pinpoint where failures occur and what causes
poor performance.</p>
<h2 id="model-1"><a class="header" href="#model-1">Model</a></h2>
<ul>
<li>
<p><strong>Span</strong></p>
<p>A span is a named, timed operation representing a piece of the operational flow. Spans can have parents and children.</p>
</li>
<li>
<p><strong>Trace</strong></p>
<p>A trace is the complete tree of spans from an entire operational flow. A new trace (with a new root span) is created
by input from an external system, such as a REST API client. Traces extend across synchronous and asynchronous message
flows (interal RPC and events).</p>
</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>The most common usage of tracing is to create a new child span within the current span, and execute an operation inside
it. To facilitate this, you can use the <code>trace.Operation()</code> function:</p>
<pre><code class="language-go">err := trace.Operation(ctx, &quot;myChildOperation&quot;, func(ctx context.Context) error {
myLogger.WithContext(ctx).Info(&quot;Inside myChildOperation...&quot;)
return nil
})
</code></pre>
<p>To create a new child span and attach data to it, you can use the <code>trace.NewSpan()</code> function:</p>
<pre><code class="language-go">// Create the new span
ctx, span := trace.NewSpan(ctx, spanName)
defer span.Finish()

// Tag the operation name
span.SetTag(trace.FieldOperation, operationName)

// Execute the operation and record the result
if err := myOperation(); err != nil {
span.LogFields(trace.Status(&quot;ERROR&quot;), trace.Error(err))
} else {
span.LogFields(trace.Status(&quot;OK&quot;))
}
</code></pre>
<p>Common trace log tags include:</p>
<ul>
<li><code>trace.FieldOperation</code>: Generic operation name</li>
<li><code>trace.FieldStatus</code>: Terminal status of the operation</li>
<li><code>trace.FieldHttpCode</code>: Response status code</li>
<li><code>trace.FieldHttpUrl</code>: Request url</li>
<li><code>trace.FieldHttpMethod</code>: Request method</li>
</ul>
<p>Other tags can be defined as needed using simple period-separated strings (e.g. <code>grpc.response.code</code>).</p>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>When writing a new driver for external input (such as a new RPC transport listener), you can retrieve the untraced
context:</p>
<pre><code class="language-go">ctx = trace.UntracedContextFromContext(ctx)
</code></pre>
<p>This context object should be passed to the input handlers, who will be responsible for starting a new (root) span:</p>
<pre><code class="language-go">err := trace.Operation(ctx, &quot;myInputReceiver&quot;, myInputHandler)
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>By default, MSX tracing will send trace data to a Jaeger listener at <code>udp://localhost:6831</code>.</p>
<p>The following configuration settings can be specified to override the default behaviour:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>trace.service-name</code></td><td>name of service to supply with the trace</td><td><code>${info.app.name}</code></td></tr>
<tr><td><code>trace.service-version</code></td><td>version of service to supply with the trace</td><td><code>${info.app.name}</code></td></tr>
<tr><td><code>trace.collector</code></td><td>which collector to use, <code>jaeger</code>,<code>datadog</code></td><td><code>jaeger</code></td></tr>
<tr><td><code>trace.reporter.enabled</code></td><td>report distributed tracing data</td><td><code>false</code></td></tr>
<tr><td><code>trace.reporter.host</code></td><td>jaeger/datadog host</td><td><code>localhost</code></td></tr>
<tr><td><code>trace.reporter.port</code></td><td>jaeger/datadog port</td><td><code>6831</code></td></tr>
<tr><td><code>trace.reporter.url</code></td><td>zipkin url</td><td><code>http://localhost:9411/api/v1/spans</code></td></tr>
</tbody></table>
</div>
<h3 id="datadog"><a class="header" href="#datadog">Datadog</a></h3>
<p>To configure for datadog, set the following values in consul:</p>
<pre><code class="language-yaml">trace.collector: datadog
trace.reporter.enabled: true
trace.reporter.port: 8126
</code></pre>
<p>and in the kubernetes manifest:</p>
<pre><code class="language-yaml">env:
- name: TRACE_REPORTER_HOST
  valueFrom:
    fieldRef:
      fieldPath: status.hostIP
</code></pre>
<p>That will send traces to the collector on the same host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operations"><a class="header" href="#operations">Operations</a></h1>
<p>In the following sections, we will explore mechanisms for reusing and augmenting
code using Functions, Actions, Operations, Decorators, Filters, and Handlers.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>In go, functions are the lowest level of reusable execution. They accept a specific
set of arguments and return a set of values.</p>
<pre><code class="language-go">func add(number1, number2 int) int {
  return number1 + number2
}
</code></pre>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>Go functions are first-class, meaning they can be passed around as values, including as
parameters to other functions, or return values from functions. This enables powerful code
composition and reuse. This is also a key feature of the functional style of programming:</p>
<blockquote>
<p>In functional programming, functions are treated as first-class citizens,
meaning that they can be bound to names (including local identifiers), passed
as arguments, and returned from other functions, just as any other data type can.
This allows programs to be written in a declarative and composable style, where
small functions are combined in a modular manner.</p>
<p>-- <a href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a>, <a href="https://en.wikipedia.org">Wikipedia</a></p>
</blockquote>
<p>In go, to accept a function as an argument, you can declare a function type, and use it to declare the receiving
parameter:</p>
<pre><code class="language-go">type unaryOperator func (int) int
type binaryOperator func(int, int) int

func evaluateUnaryExpression(operand int, operator unaryOperator) int {
  return unaryOperator(operand)
}

func evaluateBinaryExpression(leftOperand, rightOperand int, operator binaryOperator) int {
  return binaryOperator(leftOperatnd, rightOperand)
}
</code></pre>
<h2 id="actions"><a class="header" href="#actions">Actions</a></h2>
<p>go-msx defines an ActionFunc type to describe an executable function (Action) signature:</p>
<pre><code class="language-go">type ActionFunc func(ctx context.Context) error
</code></pre>
<p>An <code>ActionFunc</code> accepts a single <code>Context</code> argument (to allow access to dependencies and operation-scoped data),
and returns a single <code>error</code> value indicating success (<code>nil</code>) or failure (non-<code>nil</code>).  As described
above, this enables you to pass around these functions and abstractly re-use them:</p>
<pre><code class="language-go">// Send a message to the ANSWER_TOPIC channel
func deepThought(ctx context.Context) error {
  return stream.PublishObject('ANSWER_TOPIC', map[string]any{
    &quot;answer&quot;: 42, 		
  })
}

// Call the deepThought function when the application is running
func init() {
  app.OnEvent(app.EventRun, app.PhaseDuring, deepThought)
}
</code></pre>
<p>In this example, we register an application event observer Action to be executed
when the application has finished startup.  The Action sends a simple message to
a stream.</p>
<h2 id="operations-1"><a class="header" href="#operations-1">Operations</a></h2>
<p>To simplify reusing code to work with Actions, go-msx has an Operation type:</p>
<pre><code class="language-go">type Operation struct {...}
func (o Operation) Run(ctx context.Context) error {...}
</code></pre>
<p>Operations provide a <code>Run</code> method to execute the operation, along with other methods
to create derived Operations using Filters and Decorators.  These will be discussed in the 
next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware"><a class="header" href="#middleware">Middleware</a></h1>
<p>To augment the functionality of Actions, Operations accept a series of Decorators and Filters.
These follow the Middleware (or Mediator) pattern:</p>
<blockquote>
<p>Middleware is software that's assembled into an app pipeline to handle requests and responses. 
Each component:</p>
<ul>
<li>chooses whether to pass execution to the next component in the pipeline.</li>
<li>can perform work before and after the next component in the pipeline.</li>
</ul>
<p>-- <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x&amp;view=aspnetcore-7.0">ASP.NET Core Middleware</a>, Microsoft</p>
</blockquote>
<p>For example, when receiving an incoming web request, we use Middleware to pass the incoming request
and outgoing response through a series of stages:</p>
<pre class="mermaid">stateDiagram
    Router --&gt; Logging : Request
    Logging --&gt; Authentication : Request
    Authentication --&gt; Authorization : Request
    Authorization --&gt; Handler : Request
    Handler --&gt; Authorization : Response
    Authorization --&gt; Authentication : Response
    Authentication --&gt; Logging : Response
    Logging --&gt; Router : Response
</pre>
<p>If the Authentication filter detects a request does not carry credentials, it can reject it
immediately and return to the Logging Middleware without executing future stages in the pipeline.</p>
<p>Later, when the Authorization filter detects the logged-in user (determined by the credentials)
does not have permissions to access the requested operation, it can also reject it immediately
and return up the Middleware chain.</p>
<p>Operations support two kinds of Middleware, Decorators and Filters, described in the following sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorators"><a class="header" href="#decorators">Decorators</a></h1>
<p>A Decorator is a Middleware implementation called using the same signature as an Action:</p>
<pre><code class="language-go">action := func(context.Context) error {...}
err := action(ctx)

decoratedAction := MyDecorator(action)
err := decoratedAction(ctx)
</code></pre>
<p>As described in the previous section, Middleware (such as a Decorator) can perform checks to 
decide whether to pass control to the next Action (possibly another Middleware instance) in the
chain, or return control to its caller.</p>
<p>A Decorator can also inject values into the <code>Context</code> to provide later Actions access to calculated
data;  this is the mechanism used by the Authentication filter to inject the User Context into
the current Operation.</p>
<p>Finally, a Decorator can handle, modify or wrap the returned <code>error</code> value.  This allows
error values to be logged, mapped from one domain to another, or augmented with extra
information.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p>To apply a Decorator to an Operation, use the <code>WithDecorator</code> method to return a new, derived operation:</p>
<pre><code class="language-go">err := types.NewOperation(myAction).
	WithDecorator(NewLoggingDecorator(logger)).
	Run(ctx)
</code></pre>
<p>When adding Decorators to Operations, they wrap the inner action as they are applied.
This means that the first applied decorator will be executed right before the Action 
on the way into the Middleware pipeline, and will be executed right after the Action
on the way out of the Middleware pipeline.</p>
<p>For example:</p>
<pre><code class="language-go">err := types.NewOperation(myAction).
    WithDecorator(NewLoggingDecorator(logger)).
    WithDecorator(NewStatsDecorator(logger)).
    Run(ctx)
</code></pre>
<p>On execution of the Operation's <code>Run</code> method:</p>
<pre class="mermaid">stateDiagram
    Operation --&gt; Stats : (1) Call
    Stats --&gt; Logging : (2) Call
    Logging --&gt; myAction : (3) Call
    myAction --&gt; Logging : (4) Return
    Logging --&gt; Stats : (5) Return
    Stats --&gt; Operation : (6) Return
</pre>
<ol>
<li>Operation calls the Stats Decorator <code>Run</code> method</li>
<li>Stats calls the Logging Decorator <code>Run</code> method</li>
<li>Logging calls the <code>myAction</code> function</li>
<li><code>myAction</code> returns to the Logging Decorator</li>
<li>Logging returns to the Stats Decorator</li>
<li>Stats returns to the Operation</li>
</ol>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>A Decorator wraps an inner <code>ActionFunc</code> and returns a new <code>ActionFunc</code>.</p>
<pre><code class="language-go">type ActionFuncDecorator func(action ActionFunc) ActionFunc
</code></pre>
<h3 id="stateless"><a class="header" href="#stateless">Stateless</a></h3>
<p>Static/Stateless decorators (those which do not have runtime-specified dependencies)
can be implemented quite simply, as they do not require a factory:</p>
<pre><code class="language-go">// Static (stateless) decorator
func Escalate(action ActionFunc) ActionFunc {
    return func(ctx context.Context) error {
        return service.WithSystemContext(ctx, action)		
    }
}
</code></pre>
<h3 id="stateful-closure"><a class="header" href="#stateful-closure">Stateful Closure</a></h3>
<p>Stateful Decorators are often implemented using a closure-based factory, communicating
state via lexical scope:</p>
<pre><code class="language-go">// Factory for LoggingDecorator, accepting the dependencies,
// and returning a new decorator
func NewLoggingDecorator(logger types.Logger) ActionFuncDecorator {
    // Return the decorator, which can be applied to an Operation
    return func(action ActionFunc) ActionFunc {
        // Return the implementation of the decorator
        return func(ctx context.Context) error {
            // Call the original action
            err := action(ctx)
            // Log the error message
            if err != nil {
                logger.WithContext(ctx).WithError(err).Error(&quot;Action failed&quot;)
            }
            // Log or handle errors, never both
            return nil
        }       
    }
}
</code></pre>
<h3 id="stateful-struct"><a class="header" href="#stateful-struct">Stateful Struct</a></h3>
<p>A struct-backed Decorator object may look slightly different since it uses an object
to communicate state:</p>
<pre><code class="language-go">type StatsCounterDecorator struct {
    counterName string
    action ActionFunc
}

func (d StatsCountDecorator) Run(ctx context.Context) error {
    stats.IncrementCounter(d.counterName)
    defer stats.DecrementCounter(d.counterName)
    return d.action(ctx)
}

func NewStatsCountDecorator(counterName string) ActionFuncDecorator {
    return func(action ActionFunc) ActionFunc {
        return StatsCounterDecorator{
            counterName: counterName, 
            action: action,
        }.Run
    }	
}
</code></pre>
<p>Next, we will look at Filters, which allow Decorators to be applied in a pre-determined order
independent of the Operation instance definition.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters"><a class="header" href="#filters">Filters</a></h1>
<p>When reusing multiple Middleware types for a given Operation, it may be important that some 
middleware instances are consistently applied before others.</p>
<p>For example, our TokenFilter is applied to our HTTP pipeline to extract the token from Request
and inject it into the Context.  This must occur <em>before</em> our AuthenticationFilter checks the
token in the Context and verifies the user is properly authenticated.   Since we can swap in 
CertificateFilter for TokenFilter (when using Certificate Authentication), it important that 
the Middleware not be coupled, and always be applied in the correct order.</p>
<p>Decorators do not directly allow application in middleware-specified order.  This presents many
problems when using factories to generate higher level Operation abstractions such as Endpoints
and Message Subscribers.  These factories do not need to know about the variety or application 
order of these Decorators, especially when they are mixed with framework-specified Middleware.</p>
<p>To enable this scenario, go-msx offers Filters.  Filters allow you to ensure the correct
ordering of Middleware when passed along from other components without requiring tight
coupling or specialization.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>To apply a filter to an Operation, use the <code>WithFilter</code> method:</p>
<pre><code class="language-go">err := types.NewOperation(myAction).
	WithFilter(NewLoggingFilter(logger)).
	Run(ctx)
</code></pre>
<h3 id="order"><a class="header" href="#order">Order</a></h3>
<p>Filter Order can be though of as priority: a higher number means it will be applied earlier
to the target Action.</p>
<p>For example, if Filter A has an order of <code>0</code> and Filter B has an order of <code>100</code>, then
Filter B will be applied first (executed second inbound, first outbound), and Filter A will
be applied second (executed first inbound, second outbound).</p>
<p>Note that when combining Operation instances using the <code>Operation.Run</code> method, filters are
only ordered relative to the other Filters and Decorators on the Operation to which it was directly
applied.</p>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>A Filter is envisioned as a simple wrapper around a Decorator which also
provides a method to inspect the order that it should be applied:</p>
<pre><code class="language-go">// ActionFilter is an ordered Decorator
type ActionFilter interface {
  Order() int
  Decorator() ActionFuncDecorator
}
</code></pre>
<p>When authoring a Filter, any type that implements <code>ActionFilter</code> can be used.
You can even transform a Decorator into a Filter using a simple factory:</p>
<pre><code class="language-go">recoveryDecorator := NewRecoveryDecorator()
filter := types.NewOrderedDecorator(100, recoveryDecorator)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traced-operations"><a class="header" href="#traced-operations">Traced Operations</a></h1>
<p>The Tracing module has some convenience methods which allow you to create traced operations,
along with the ability to execute them in the foreground or background.</p>
<h2 id="factories"><a class="header" href="#factories">Factories</a></h2>
<p>The Tracing module defines two Operation factories which can create named and traced Operations.</p>
<h3 id="newoperation"><a class="header" href="#newoperation">NewOperation</a></h3>
<p>To create an Operation which has Distributed Tracing enabled, use the <code>NewOperation</code>
factory.</p>
<p>For example:</p>
<pre><code class="language-go">op := trace.NewOperation(&quot;multipleTwoNumbers&quot;, multiplyTwoNumbers)
</code></pre>
<p>This will create an Operation with two decorators:</p>
<ul>
<li><strong>SpanDecorator</strong>: Records an operation and its outcome in the distributed trace.  If there 
is a trace in progress, a new child span will be created inside the current span.</li>
<li><strong>RecoverLogDecorator</strong>: If your Action panics, this will stop propagation and log the details.</li>
</ul>
<p>You can add further Middleware to the returned Operation, or consume it as-is.</p>
<h3 id="newisolatedoperation"><a class="header" href="#newisolatedoperation">NewIsolatedOperation</a></h3>
<p>The create an operation which has Distributed Tracing enabled, but is <em>not</em> part of the 
current trace, use the <code>NewIsolatedOperation</code> factory.</p>
<p>For example:</p>
<pre><code class="language-go">op := trace.NewIsolatedOperation(&quot;multipleTwoNumbers&quot;, multiplyTwoNumbers)
</code></pre>
<p>This uses <code>NewOperation</code> above, and then applies the following decorator:</p>
<ul>
<li><strong>UntracedContextDecorator</strong>: Removes reference to the current span before a new span is created.
This has the effect of starting a new trace, completely independent of the calling context.</li>
</ul>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>The Tracing module defines two Operation executors which can create and then execute
Traced Operations.</p>
<h3 id="foregroundoperation"><a class="header" href="#foregroundoperation">ForegroundOperation</a></h3>
<p>ForegroundOperation executes the action inside a new, isolated trace:</p>
<pre><code class="language-go">err := trace.ForegroundOperation(ctx, &quot;simple&quot;, mySimpleAction)
</code></pre>
<h3 id="backgroundoperation"><a class="header" href="#backgroundoperation">BackgroundOperation</a></h3>
<p>BackgroundOperation executes an action inside a background goroutine, using
a new, isolated trace:</p>
<pre><code class="language-go">trace.BackgroundOperation(ctx, &quot;simple&quot;, mySimpleAction)
</code></pre>
<p>This call does not offer persistence, cancellation, or restartability, so should not be used
for job execution or management.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ports"><a class="header" href="#ports">Ports</a></h1>
<p><em>Ports</em> describe the format of an incoming or outgoing stream or HTTP endpoint.<br />
They are used to automatically serialize and deserialize communications to a convenient
structure for your application.</p>
<p>The term &quot;Ports&quot; is taken from Hexagonal Architecture, where it used to describe </p>
<blockquote>
<p>... dedicated interfaces to communicate with the outside world. 
They allow the entry or exiting of data to and from the application.</p>
<p>-- <a href="https://medium.com/idealo-tech-blog/hexagonal-ports-adapters-architecture-e3617bcf00a0">Hexagonal Architecture</a>, Medium</p>
</blockquote>
<p>go-msx uses two types of ports, with many overlapping options:</p>
<ul>
<li><strong>Input Port</strong>: describes an HTTP request or incoming Stream Message</li>
<li><strong>Output Port</strong>: describes an HTTP response or outgoing Stream Message</li>
</ul>
<h3 id="declaration"><a class="header" href="#declaration">Declaration</a></h3>
<p>Ports are defined using go structures, consisting of a series of fields.
Each field consists of three parts:</p>
<ol>
<li>
<p><strong>Name</strong>: The name by which you can access the struct member in go code.</p>
</li>
<li>
<p><strong>Type</strong>: The type of the field to which the data will be converted.
These types fall into one of a few categories, to simplify conversion:</p>
<ul>
<li>Scalar: Any simple single-valued (eg string, int, uuid, bool)</li>
<li>Array: A sequence of scalars</li>
<li>Object: A dictionary of scalars with string keys</li>
<li>File: An uploaded file</li>
<li>FileArray: A sequence of uploaded files</li>
</ul>
</li>
<li>
<p><strong>Tags</strong>: A set of annotations of the struct field, describing attributes
like source/destination, index, validation, optionality, etc. </p>
</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-go">type outputs struct {
    Code   int          `resp:&quot;code&quot;`
    Body   api.Response `resp:&quot;body&quot;`
    Error  api.Error    `resp:&quot;body&quot; error:&quot;true&quot;`
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input-ports"><a class="header" href="#input-ports">Input Ports</a></h1>
<p>An Input Port is a go structure used to describe a source payload to be parsed,
such as an HTTP Request or an incoming Stream Message.</p>
<p>Upon receipt of an incoming payload, go-msx will populate your data structure, execute 
validation, and if it is valid, pass it to your handler, such as an HTTP Controller Endpoint.</p>
<p>An example stream message input port:</p>
<pre><code class="language-go">type driftCheckResponseInputs struct {
    EventType string                 `in:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   api.DriftCheckResponse `in:&quot;body&quot;`
}
</code></pre>
<p>An example HTTP request input port:</p>
<pre><code class="language-go">type createEntityInputs struct {
    ControlPlaneId types.UUID              `req:&quot;path&quot;`
    Payload        api.CreateEntityRequest `req:&quot;body&quot;`	
}
</code></pre>
<h2 id="struct-tags"><a class="header" href="#struct-tags">Struct Tags</a></h2>
<p>Each field with an input struct tag will be automatically populated before being
passed to your handler.</p>
<p>Note that the struct tag prefix depends on the protocol being described:</p>
<ul>
<li>For HTTP Requests, the input struct tag must be <code>req</code> (for backwards compatibility)</li>
<li>For Stream Messages, the input struct tag must be <code>in</code>.</li>
</ul>
<p>The full syntax of the input struct tag is one of the following, appropriate for
the handling protocol:</p>
<pre><code>in:&quot;&lt;fieldGroup&gt;[=&lt;peerName&gt;]&quot;
req:&quot;&lt;fieldGroup&gt;[=&lt;peerName&gt;]&quot;
</code></pre>
<p>The input struct tag contains the following subcomponents:</p>
<ul>
<li>
<p><code>&lt;fieldGroup&gt;</code> (<em>Required</em>):
The name of the message/request part from which the value will be extracted.</p>
</li>
<li>
<p><code>[=&lt;peerName&gt;]</code> (<em>Optional</em>):
A <em>peer</em> is a field or property in the source message 
For example an HTTP request may have a header with the name date, which can be requested
using the following input struct tag: <code>req:&quot;header=Date&quot;</code> </p>
</li>
</ul>
<p>See <a href="ops/docs/">HTTP Request Ports</a> and <a href="ops/docs/../streamops/ports.html">Stream Ports</a> for available field groups and peer
name conventions for your specific protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-ports"><a class="header" href="#output-ports">Output Ports</a></h1>
<p>An Output Port is a go structure used to describe a target payload to be generated,
such as an HTTP Response or an outgoing Stream Message.</p>
<p>The port structure must be populated by you before being either:</p>
<ul>
<li>passed into the stream Message Publisher; or</li>
<li>returned from your HTTP Endpoint Controller</li>
</ul>
<p>go-msx will validate the contents of your structure and if it is valid,
publish the message or response.</p>
<p>An example stream message output port:</p>
<pre><code class="language-go">type driftCheckResponseOutputs struct {
    EventType string                 `out:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   api.DriftCheckResponse `out:&quot;body&quot;`
}
</code></pre>
<p>An example HTTP response input port:</p>
<pre><code class="language-go">type createEntityOutputs struct {
    Payload api.CreateEntityResponse `resp:&quot;body&quot;`	
}
</code></pre>
<h3 id="struct-tags-1"><a class="header" href="#struct-tags-1">Struct Tags</a></h3>
<p>Each field with an output struct tag will be applied to the outgoing payload.</p>
<p>Note that the struct tag prefix depends on the protocol being described:</p>
<ul>
<li>For HTTP Requests, the output struct tag must be <code>resp</code> (for backwards compatibility)</li>
<li>For Stream Messages, the output struct tag must be <code>out</code>.</li>
</ul>
<p>The full syntax of the input struct tag is one of the following, appropriate for
the handling protocol:</p>
<pre><code>output:&quot;&lt;fieldGroup&gt;[=&lt;peerName&gt;]&quot;
resp:&quot;&lt;fieldGroup&gt;[=&lt;peerName&gt;]&quot;
</code></pre>
<p>The output struct tag contains the following subcomponents:</p>
<ul>
<li>
<p><code>&lt;fieldGroup&gt;</code> (<em>Required</em>):
The name of the message/response part to which the value will be injected.</p>
</li>
<li>
<p><code>[=&lt;peerName&gt;]</code> (<em>Optional</em>):
A <em>peer</em> is a field or property in the target payload. For example an HTTP response may have
a header with the name date, which can be requested using the following output struct tag: <code>resp:&quot;header=Date&quot;</code> </p>
</li>
</ul>
<p>See <a href="ops/docs/">HTTP Response Ports</a> and <a href="ops/docs/../streamops/ports.html">Stream Ports</a> for available field groups and peer
name conventions for your specific protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>Port structures use struct tags to declare JSON Schema
constraints for fields within the port and data transfer objects.</p>
<pre><code class="language-go">type driftCheckResponseInput struct {
    EventType string                 `in:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   api.DriftCheckResponse `in:&quot;body&quot;`
}
</code></pre>
<p>For example, in the <code>driftCheckRequestInput</code> port, the <code>EventType</code> field
specifies it must contain the constant value <code>DriftCheck</code> through the <code>const</code> tag.</p>
<p>When generating AsyncApi documentation, validation constraints specified in the port
struct or the data transfer object will automatically be included in the documentation.</p>
<h2 id="json-schema-struct-tags"><a class="header" href="#json-schema-struct-tags">JSON Schema Struct Tags</a></h2>
<p><a href="https://json-schema.org/">JSON Schema</a> is a domain-specific language used to describe constraints on values
that may be expressed using the JSON type system (null, object, array, number, string).</p>
<p>The following struct tags may be used to specify JSON Schema constraints and validators
within a port struct or a data transfer object:</p>
<ul>
<li>
<p><code>optional</code>, <code>required</code></p>
<p>Boolean entries to override the base field type optionality.  By default, pointer/slice/map and <code>types.Optional</code>
types are optional, and other types are non-optional.  Must be &quot;true&quot; or &quot;false&quot;.</p>
<pre><code class="language-go">type inPort struct {
    Expiry     types.Duration  `in=&quot;header&quot; optional=&quot;true&quot;`
    BestBefore *types.Duration `in=&quot;header&quot; required=&quot;true&quot;`
}
</code></pre>
</li>
<li>
<p><code>deprecated</code></p>
<p>Boolean to indicate the field should not be used and will be removed. Must be &quot;true&quot; or &quot;false&quot;.</p>
<pre><code class="language-go">type inPort struct {
    VmsTenant types.UUID `in=&quot;header&quot; deprecated=&quot;true&quot;`  
}
</code></pre>
</li>
<li>
<p><code>title</code>, <code>description</code></p>
<p>Expository language to help users understand the purpose of the field.</p>
<pre><code class="language-go">type outPort struct {
    ContentType string `in=&quot;header&quot; title=&quot;Content Type&quot; description=&quot;MIME type for the message body&quot; example=&quot;application/xml&quot;`
}
</code></pre>
</li>
<li>
<p><code>const</code></p>
<p>Value that the field must contain to be valid.  Equivalent to a single-valued <code>enum</code>.
Must be a scalar convertible to a valid value of the field data type.
See &quot;Port Field Constraint Handling&quot;, below for more details.</p>
<pre><code class="language-go">type MyRequest struct {
    Answer int `in=&quot;header&quot; const=&quot;42&quot;`  
}
</code></pre>
</li>
<li>
<p><code>default</code></p>
<p>Default value that the field will <em>behave as having</em> if not explicitly specified.
Must be a scalar convertible to a valid value of the field data type.
See &quot;Port Field Constraint Handling&quot;, below for more details.</p>
<pre><code class="language-go">type MyRequest struct {
    Pi float64 `in=&quot;header&quot; default=&quot;3.14&quot;`  
}
</code></pre>
</li>
<li>
<p><code>example</code></p>
<p>Example value to be presented in the schema document.
Must be a scalar convertible to a valid value of the field data type.</p>
<pre><code class="language-go">type MyRequest struct {
    Hour int   `in=&quot;header&quot; example=&quot;12&quot;`
    Minute int `in=&quot;header&quot; example=&quot;30&quot;`  
}
</code></pre>
</li>
<li>
<p><code>enum</code></p>
<p>Comma-separated list of possible values for the field.
Only these values will be accepted by the field during validation.
Must be scalars convertible to the field data type.</p>
<pre><code class="language-go">type MyResponseOutput struct {
    Code int `out=&quot;code&quot; enum=&quot;200,400,401,403,404&quot;` 
}
</code></pre>
</li>
<li>
<p><code>minimum</code>, <code>maximum</code></p>
<p>Range constraints for possible values of the field.
Only values &gt;= minimum (if specified) are valid.
Only values &lt;= maximum (if specified) are valid.
Must be scalars convertible to the field data type.</p>
<pre><code class="language-go">type MyResponseOutput struct {
    Radians float64 `out=&quot;header&quot; minimum=&quot;0&quot; maximum=&quot;6.28&quot;` 
}
</code></pre>
</li>
<li>
<p><code>minLength</code>, <code>maxLength</code></p>
<p>Length constraints for value of the field.  Applies
to <code>string</code> fields.  Must be integers if specified.</p>
<pre><code class="language-go">type MyResponse struct {
     ServiceType string `in=&quot;header&quot; minLength=&quot;4&quot; maxLength=&quot;16&quot;`
}
</code></pre>
</li>
<li>
<p><code>maxProperties</code>, <code>minProperties</code></p>
<p>Length constraints for value of the field.  Applies
to <code>object</code> fields.  Must be integers if specified.</p>
<pre><code class="language-go">type MyResponse struct {
     ServiceType map[string]string `in=&quot;header&quot; minProperties=&quot;1&quot;`
}
</code></pre>
</li>
<li>
<p><code>pattern</code></p>
<p>Regular expression that values must match to be valid.  Applies
to <code>string</code> fields.</p>
<pre><code class="language-go">type MyResponse struct {
     DeviceId string `in=&quot;header&quot; pattern=&quot;^CPE-.*$&quot;`
}
</code></pre>
</li>
<li>
<p><code>format</code></p>
<p>String identifier of pre-defined formats.  Applies
to <code>string</code> fields.  Normally will be automatic based on
the underlying field type.</p>
<pre><code class="language-go">type MyResponse struct {
     When types.Time `in=&quot;header&quot; format=&quot;date&quot;`
}
</code></pre>
</li>
<li>
<p><code>minItems</code>, <code>maxItems</code></p>
<p>Length constraints for value of the field. Applies
to <code>array</code> fields (slices).  Must be integers if specified.</p>
<pre><code class="language-go">type MyRequest struct {
     DeviceIds []types.UUID `in=&quot;body&quot; minItems=&quot;1&quot;`
     TenantIds []types.UUID `in=&quot;body&quot; maxItems=&quot;1&quot;`
}
</code></pre>
</li>
</ul>
<p>The underlying jsonschema-go library provides a few more constraints,
which you can view at the package <a href="https://pkg.go.dev/github.com/swaggest/jsonschema-go#readme-field-tags">GoDoc</a></p>
<h3 id="special-tags"><a class="header" href="#special-tags">Special Tags</a></h3>
<p>Ports have a few special tags which can be applied at the top level:</p>
<ul>
<li>
<p><code>validation</code></p>
<p>Boolean enabling or disabling validation.  Documentation will still be generated as if
validation is enabled.</p>
</li>
</ul>
<h3 id="constraints-on-named-types"><a class="header" href="#constraints-on-named-types">Constraints on Named Types</a></h3>
<p>Fields in Port structures and DTOs with simple and anonymous types may be augmented using the JSON schema
tags above.  However, named types are shared across many fields and therefore cannot be augmented in-place.
For example:</p>
<pre><code class="language-go">type DriftCheckRequest struct {
  Action                string          `json:&quot;action&quot; const:&quot;checkDrift&quot;`
  GroupId               types.UUID      `json:&quot;groupId,omitempty&quot;`
  Timestamp             types.Time      `json:&quot;timestamp&quot; minimum:&quot;2022-01-01T00:00:00Z&quot;`
  EntityLevelCompliance string          `json:&quot;entityLevelCompliance&quot; enum:&quot;full,partial&quot;`
  Standards             []ConfigPayload `json:&quot;standards,omitempty&quot; minItems:&quot;1&quot; required:&quot;true&quot;`
  ...
}
</code></pre>
<p>Fields with Named Types include:</p>
<ul>
<li><code>GroupId</code> : <code>types.UUID</code></li>
<li><code>Timestamp</code> : <code>types.Time</code></li>
</ul>
<p>These fields will ignore any schema constraints declared in the struct tag,
such as the <code>minimum</code> tag on <code>Timestamp</code>.</p>
<p>Fields with Simple or Anonymous Types include:</p>
<ul>
<li><code>Action</code> : <code>string</code></li>
<li><code>EntityLevelCompliance</code> : <code>string</code></li>
<li><code>Standards</code>: <code>[]ConfigPayload</code></li>
</ul>
<p>Each of these fields has schema constraints declared which will be honoured.
<code>Standards</code> is an array of DTOs <code>[]ConfigPayload</code> and therefore is of an anonymous
type.</p>
<h3 id="constraints-on-dto-structs"><a class="header" href="#constraints-on-dto-structs">Constraints on DTO structs</a></h3>
<p>To configure a parent DTO struct using struct tags, include an anonymous 
field <code>_</code> with the desired constraints.  For example:</p>
<pre><code class="language-go">type RemediateRequest struct {
	...
    _ struct{} `additionalProperties:&quot;false&quot; description:&quot;RemediateRequest contains a remediation request.&quot;`
}
</code></pre>
<p>This will add <code>description</code> and <code>additionalProperties</code> schema constraints
to the <code>RemediateRequest</code> struct in the schema.</p>
<h3 id="custom-schema-generation-for-named-types"><a class="header" href="#custom-schema-generation-for-named-types">Custom Schema Generation for Named Types</a></h3>
<p>The underlying jsonschema-go library provides a number of interfaces to customize
or replace the JSON schema generated for your Named Type:</p>
<ul>
<li><code>NamedEnum</code> - Provides a list of name/value pairs for your enumerable type.</li>
<li><code>Enum</code> - Provides a list of values for your enumerable type.</li>
<li><code>Preparer</code> - Intercepts the reflected JSON Schema and allows alteration.</li>
<li><code>Exposer</code> - Provides a complete parsed JSON Schema for your type.</li>
<li><code>RawExposer</code> - Provides a complete unparsed JSON Schema for your type.</li>
<li><code>OneOfExposer</code> - Provides a list of <code>oneOf</code> elements for your type.</li>
<li><code>AnyOfExposer</code> - Provides a list of <code>anyOf</code> elements for your type.</li>
<li><code>AllOfExposer</code> - Provides a list of <code>allOf</code> elements for your type.</li>
<li><code>NotExposer</code> - Provides a <code>not</code> element for your type.</li>
<li><code>IfExposer</code> - Provides an <code>if</code> element for your type.</li>
<li><code>ThenExposer</code> - Provides a <code>then</code> element for your type.</li>
<li><code>ElseExposer</code> - Provides an <code>else</code> element for your type.</li>
</ul>
<p>You can find more details about these interfaces on the package
<a href="https://pkg.go.dev/github.com/swaggest/jsonschema-go#readme-implementing-interfaces-on-a-type">GoDoc</a>.</p>
<h3 id="port-field-constraint-handling"><a class="header" href="#port-field-constraint-handling">Port Field Constraint Handling</a></h3>
<p>To ease development burden, when using <code>const</code> or <code>default</code> on a Port Field, the value will be applied
during input population (subscriber) or output population (publisher).  Note that this only applies to
scalars (e.g. headers), and only those directly contained in the Port structure.  In particular, it does
not apply to the request/response body or its sub-fields.</p>
<p>From the example at the beginning of the chapter:</p>
<pre><code class="language-go">type driftCheckRequestOutput struct {
    EventType string            `out:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   DriftCheckRequest `out:&quot;body&quot;`
}

type DriftCheckRequest struct {
    Action string `json:&quot;action&quot; const:&quot;checkDrift&quot;`
    ...
}
</code></pre>
<p>The <code>EventType</code> field of <code>driftCheckRequestOutput</code> will be filled with <code>DriftCheck</code> if not supplied
by the publisher, since it is a scalar, and directly contained within the Port structure.  If another
value is supplied, the schema validation will fail, so it is best to simply not supply the value.</p>
<p>The <code>Action</code> field of <code>DriftCheckRequest</code> will <em>not</em> be filled with <code>checkDrift</code> since it is not
directly contained within the Port structure.  It will be validated during schema validation to ensure
only that value is supplied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="services"><a class="header" href="#services">Services</a></h1>
<p>A service is a reusable part of an application.  Services are used to isolate responsibility
and are composed to provide functionality. Example services include:</p>
<ul>
<li>REST Controller</li>
<li>Application Service</li>
<li>Stream Message Subscriber</li>
<li>Database Repository</li>
<li>API Integration</li>
</ul>
<p>Each service may have a number of supporting components and functions:</p>
<ul>
<li>Interface Definition</li>
<li>Mock</li>
<li>Structure</li>
<li>Dependencies</li>
<li>Implementation</li>
<li>Abstract Constructor</li>
<li>Lifecycle Registration (for root components)</li>
</ul>
<p>Let's look at each of these using an example Application Service, <code>HelloWorldService</code>. </p>
<h2 id="interface-definition"><a class="header" href="#interface-definition">Interface Definition</a></h2>
<p>To enable test duplicate (mock) substitutions, you should define an interface declaring the
public methods of your component.  In our example, we have one method, <code>SayHello</code>:</p>
<pre><code class="language-go">type HelloWorldService interface {
	SayHello(context.Context) (string, error)
}
</code></pre>
<p>This interface type will be used later by our Abstract Constructor to ensure we provide
any substituted dependency instead of returning a live object when requested during testing.</p>
<p>The interface should be externally visible (capitalized) so that other modules can re-use it.
This opposes the standard go convention of &quot;interface definition by consumer&quot; enabled by
duck typing, however it allows you to pre-generate mocks for your consumers' testing needs.</p>
<h2 id="mock"><a class="header" href="#mock">Mock</a></h2>
<p>Each service (other than root components) will be re-used by one ore more other services,
and therefore should provide a mock.  Using mockery, for example:</p>
<pre><code class="language-go">//go:generate mockery --name=HelloWorldService --case=snake --with-expecter
</code></pre>
<p>This mock will be generated automatically when you run <code>go generate</code>, such as when using
the <code>make generate</code> target.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Each service is defined using a simple go structure:</p>
<pre><code class="language-go">type helloWorldService struct {} 
</code></pre>
<p>In most situations, you do not want to make the implementation visible outside the current module,
and therefore the structure name should start with a lowercase letter.  Consumers of your structure 
will receive a reference via the Interface, which will be visible externally.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>A service often depends on other services (provided by the go-msx framework, your application,
or third parties).  These dependencies are declared in the service structure.  For example,
our <code>HelloWorldService</code> can depend on a repository:</p>
<pre><code class="language-go">type helloWorldService struct {
	helloWorldRepository HelloWorldRepository
}
</code></pre>
<p>Dependencies should be declared in the structure by referring to their abstract (interface)
type, so that during coverage testing, you can use Mocks to test all code paths.</p>
<p>Module dependencies should not be declared in the structure, but rather in the local <code>pkg.go</code>.
This includes loggers.</p>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>Each service will have a series of public functions matching the Interface Definition:</p>
<pre><code class="language-go">func (r *helloWorldService) SayHello(ctx context.Context) (string, error) {
	return &quot;Hello, World&quot;, nil
}
</code></pre>
<p>Service methods should use a pointer receiver, as they will be passed around on the heap
inside an interface reference.</p>
<h2 id="context-accessor"><a class="header" href="#context-accessor">Context Accessor</a></h2>
<p>Each substitutable component in go-msx requires a context accessor to allow injecting and
inspecting overrides:</p>
<pre><code class="language-go">func ContextHelloWorldService() types.ContextAccessor[HelloWorldService] {
	return types.NewContextAccessor[HelloWorldService](contextKeyNamed(&quot;HelloWorldService&quot;))
}
</code></pre>
<p>Key to type safety is the external invisibility of the context key.  This is guaranteed
by defined a module-local type (<code>contextKey</code> or <code>contextKeyNamed</code>) and using an instance of it
to index the context inspection/injection.</p>
<h2 id="abstract-constructor"><a class="header" href="#abstract-constructor">Abstract Constructor</a></h2>
<p>To manage the injection of dependencies, go-msx applications use abstract constructors in
the style of go factories.  In particular, they:</p>
<ul>
<li>return a reference to an interface type instead of the concrete implementation;</li>
<li>check the passed-in Context for overrides for the component, and if found, return it;</li>
<li>fail on error in constructing any subcomponents</li>
<li>check configuration to select from alternative dependencies</li>
</ul>
<p>Our service has a single, simple dependency:</p>
<pre><code class="language-go">func NewHelloWorldService(ctx context.Context) (result HelloWorldService, err error) {
	var ok bool
	if result, ok = ContextHelloWorldService().TryGet(ctx); !ok {
        helloWorldRepository, err := NewHelloWorldRepository(ctx)
		if err != nil { 
			return nil, err
		}
		
		result = &amp;helloWorldService{
            helloWorldRepository: helloWorldRepository,
        }
    }
	
	return
}
</code></pre>
<h2 id="lifecycle-registration"><a class="header" href="#lifecycle-registration">Lifecycle Registration</a></h2>
<p>For root components (those not instantiated by other components), you must instantiate them
during application startup.  Components that should be created for all commands should use
the <code>OnEvent</code> registration:</p>
<pre><code class="language-go">func init() {
	var svc helloWorldService
	app.OnEvent(
		app.EventStart,
		app.EventDuring,
		func (ctx context.Context) (err error) {
			svc, err = NewHelloWorldService(ctx)
			return err
        })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api-controller"><a class="header" href="#rest-api-controller">REST API Controller</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Controller is to accept REST-based API requests from callers (UI, swagger, other microservices),
and route them to the service.</p>
<h2 id="defining-the-controller-structure"><a class="header" href="#defining-the-controller-structure">Defining the Controller structure</a></h2>
<p>To define a controller, create a standard Go structure with fields for its required dependencies:</p>
<pre><code class="language-go">type productController struct {
    productService   *productService
    productConverter *productConverter
}
</code></pre>
<p>This example shows two common dependencies:</p>
<ul>
<li>Service
<ul>
<li>The service is responsible for responding to the requests.  The controller acts as an HTTP gateway
to the service functionality.</li>
</ul>
</li>
<li>Converter
<ul>
<li>The converter transforms data transfer objects (requests and response) to and from domain models.</li>
</ul>
</li>
</ul>
<h2 id="implementing-the-restcontroller-interface"><a class="header" href="#implementing-the-restcontroller-interface">Implementing the RestController interface</a></h2>
<p>For registration with the web server, the <code>webservice.RestController</code> interface defines a single required method, <code>Routes</code>.
Add a standard implementation to your controller, for example:</p>
<pre><code class="language-go">func (c *productController) Routes(svc *restful.WebService) {
	tag := webservice.TagDefinition(&quot;Products&quot;, &quot;Products Controller&quot;)
	webservice.Routes(svc, tag,
		c.listProducts,
		c.getProduct,
		c.createProduct,
		c.updateProduct,
		c.deleteProduct)
}
</code></pre>
<p>This implementation demonstrates:</p>
<ul>
<li>Adding each endpoint implementation to the supplied WebService.</li>
<li>Tagging the routes for Swagger.  This allows the Swagger UI to show the human-readable controller name and group endpoints properly.
Note that the tag does not have to be unique, and can be declared at module level to be used across multiple controllers (eg v1, v2).
This will show all of the endpoints from the chosen controllers in a single group.</li>
</ul>
<h2 id="implementing-an-endpoint"><a class="header" href="#implementing-an-endpoint">Implementing an Endpoint</a></h2>
<p>Each endpoint on your controller should be declared inside its own method.  Here's an example implementation of a List endpoint
for the Products controller:</p>
<pre><code class="language-go">var viewPermissionFilter   = webservice.PermissionsFilter(rbac.PermissionViewProduct)

func (c *productController) listProducts(svc *restful.WebService) *restful.RouteBuilder {
    type params struct {
        Category *string `req:&quot;query&quot;`
    }

    return svc.GET(&quot;&quot;).
        Operation(&quot;listProducts&quot;).
        Doc(&quot;Retrieve the list of products, optionally filtering by the specified criteria.&quot;).
        Do(webservice.StandardList).
        Do(webservice.ResponsePayload(api.ProductListResponse{})).
        Do(webservice.PopulateParams(params{})).
        Filter(viewPermissionFilter).
        To(webservice.Controller(
            func(req *restful.Request) (body interface{}, err error) {
                params = webservice.Params(req).(*params)
        
                products, err := c.productService.ListProducts(req.Request.Context(), params.Category)
                if err != nil {
                    return nil, err
                }
        
                return c.productConverter.ToProductListResponse(products), nil
            }))
}
</code></pre>
<p>Here we are declaring the endpoint:</p>
<ul>
<li><code>type params ...</code>
<ul>
<li>accepts an optional string parameter <code>category</code> as a query parameter</li>
</ul>
</li>
<li><code>svc.GET</code>
<ul>
<li>will use the GET HTTP method</li>
</ul>
</li>
<li><code>GET(&quot;&quot;)</code>
<ul>
<li>has the same path as the controller</li>
</ul>
</li>
<li><code>Operation(&quot;listProducts&quot;)</code>
<ul>
<li>has the operation name <code>listProducts</code>.  This will appear in tracing, logs, and in the swagger definition.</li>
</ul>
</li>
<li><code>Doc(&quot;...&quot;)</code>
<ul>
<li>has the supplied description in the Swagger UI</li>
</ul>
</li>
<li><code>Do(webservice.StandardList)</code>
<ul>
<li>is an implementation of a List Collection endpoint.  Returns 200 by default.</li>
</ul>
</li>
<li><code>Do(webservice.PopulateParams(params{}))</code>
<ul>
<li>populates request parameters into the supplied structure</li>
</ul>
</li>
<li><code>Do(webservice.ResponsePayload(api.ProductListResponse{}))</code>
<ul>
<li>will return the specified response DTO, wrapped <em>inside</em> an MsxEnvelope object.</li>
</ul>
</li>
<li><code>Filter(viewPermissionFilter)</code>
<ul>
<li>will check that callers have the &quot;VIEW_PRODUCT&quot; permission, as defined in
the viewPermissionFilter object</li>
</ul>
</li>
<li><code>To(webservice.Controller(func ...))</code>
<ul>
<li>will execute the supplied function when this endpoint is called</li>
</ul>
</li>
</ul>
<p>These are some possible route building functions available in go-msx.  You may use the go-restful routing functions, along with the <a href="webservice/routes.go">go-msx routing functions</a> to define many aspects of your endpoint.</p>
<h3 id="validation-1"><a class="header" href="#validation-1">Validation</a></h3>
<p>Controller parameter validation can be performed in two ways:</p>
<ol>
<li>
<p>Any member of the <code>params</code> struct passed into <code>webservice.PopulateParams</code> which implement the <code>validate.Validatable</code> interface
will be validated before being passed into the controller via a request attribute.</p>
<p>Create and Update request bodies will generally implement this interface.  For example:</p>
<pre><code class="language-go">type SubscriptionCreateRequest struct {
    OfferId   string `json:&quot;offerId&quot;`
    TenantId  string `json:&quot;tenantId&quot;`
    ServiceId string `json:&quot;serviceId&quot;`
}

func (s *SubscriptionCreateRequest) Validate() error {
    return types.ErrorMap{
        &quot;offerId&quot;: validation.Validate(&amp;s.OfferId, validation.Required, is.UUID),
        &quot;tenantId&quot;: validation.Validate(&amp;s.TenantId, validation.Required, is.UUID),
        &quot;serviceId&quot;: validation.Validate(&amp;s.ServiceId, validation.Required, is.UUID),
    }
}
</code></pre>
</li>
<li>
<p>A custom validation function may be provided using <code>.Do(requestValidatorFunc)</code>.  Extending the example above
which contains a <code>Category</code> parameter:</p>
<pre><code class="language-go">    ...
    Do(webservice.ValidateParams(func(req *restful.Request) (err error) {
        params, ok := webservice.Params(req).(*params)
        if !ok {
            return webservice.NewInternalError(errors.New(&quot;incorrect params type&quot;))
        }
        return types.ErrorMap{
            &quot;category&quot;: validation.Validate(&amp;params.Category, 
                                            validation.Required, 
                                            validation.In(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),
        }
    })).
</code></pre>
</li>
</ol>
<p>Any non-nil errors returned by the validation function will cause a <code>400 BAD REQUEST</code> response detailing
the validation errors.</p>
<p>Common validators are provided by the <a href="https://github.com/go-ozzo/ozzo-validation">github.com/go-ozzo/ozzo-validation</a> package.
A few custom validators are available in the <a href="webservice/../validate/README.html">validate</a> package.</p>
<h2 id="implementing-a-constructor"><a class="header" href="#implementing-a-constructor">Implementing a Constructor</a></h2>
<p>To allow instantiation of your controller, you can provide a constructor:</p>
<pre><code class="language-go">func newProductController(ctx context.Context) webservice.RestController {
	return &amp;productController{
        productService:   newProductService(ctx),
        productConverter: productConverter{},
	}
}
</code></pre>
<p>In this case, we expect the product service to be injectable, so we use its constructor function
to create an instance of the dependency. This simplifies unit testing by allowing us to inject
a mock for the service.</p>
<p>In contrast, we do not expect to use a mock converter, so it is instantiated directly.</p>
<h2 id="connecting-the-controller-to-the-application-lifecycle"><a class="header" href="#connecting-the-controller-to-the-application-lifecycle">Connecting the Controller to the Application Lifecycle</a></h2>
<p>In order to instantiate your controller during application startup, you can register a simple
<code>init</code> function:</p>
<pre><code class="language-go">func init() {
	app.OnEvent(app.EventCommand, app.CommandRoot, func(ctx context.Context) error {
		app.OnEvent(app.EventStart, app.PhaseBefore, func(ctx context.Context) error {
			controller := newProductController(ctx)
			return webservice.
				WebServerFromContext(ctx).
				RegisterRestController(pathRoot, controller)
		})
		return nil
	})
}
</code></pre>
<p>This will register your controller during normal microservice startup.  Since it
is only registering for <code>CommandRoot</code>, it will not be created during <code>migrate</code>, 
<code>populate</code> or other custom command execution.</p>
<p>To ensure your module is included in the built microservice, include the module from your <code>main.go</code>:</p>
<pre><code class="language-go">import _ &quot;cto-github.cisco.com/NFV-BU/productservice/internal/products&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api-controller-1"><a class="header" href="#rest-api-controller-1">REST API Controller</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Controller is to accept REST-based API requests from callers (UI, swagger, other microservices),
and route them to the service.</p>
<p>To generate a complete domain, including the controller, use the <a href="ops/restops/docs/../../../skel/docs/usage.html">skel</a> tool.</p>
<p>In the <a href="ops/restops/docs/../../../types/docs/services.html">Services</a> section, we described the various components of every
service, including REST API Controllers. The following sections assumes your familiarity with
those components.</p>
<p>REST Controllers have specific requirements for:</p>
<ul>
<li>Interface Definition</li>
<li>Mock</li>
<li>Dependencies</li>
<li>Implementation</li>
<li>Lifecycle Registration (for root components)</li>
</ul>
<h2 id="interface-definition-1"><a class="header" href="#interface-definition-1">Interface Definition</a></h2>
<p>The REST controller component is never mocked as it is a root component.
No interface definition is required.</p>
<h2 id="mock-1"><a class="header" href="#mock-1">Mock</a></h2>
<p>The REST controller component is never mocked as it is a root component.
No mock generation is required.</p>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<p>REST Controllers typically depend exclusively on the Application Service. For example:</p>
<pre><code class="language-go">type applicationController struct {
    applicationService ApplicationServiceApi
}
</code></pre>
<p>The converter dependency has moved to the Application Service, which now receives and returns
DTOs.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<h3 id="endpointsproducer"><a class="header" href="#endpointsproducer"><code>EndpointsProducer</code></a></h3>
<p>Modern go-msx REST Controllers must implement the <code>restops.EndpointsProducer</code> interface.
The <code>Endpoints</code> function returns a list of endpoints implemented by the controller:</p>
<pre><code class="language-go">func (c *applicationController) Endpoints() (restops.Endpoints, error) {
    builders := restops.EndpointBuilders{
        c.getConfigApplicationResultsByConfigApplicationId(),
        ...
    }

    return builders.Endpoints()
}
</code></pre>
<p>Each endpoint or builder is generated by calling a method on the controller from
the <code>Endpoints</code> function. These are then aggregated and returned as a slice of Endpoints.</p>
<h3 id="endpointtransformersproducer"><a class="header" href="#endpointtransformersproducer"><code>EndpointTransformersProducer</code></a></h3>
<p>A controller may also implement the <code>restops.EndpointTransformersProducer</code> interface
in order to apply transformations to each of the registered endpoints, including tagging
and path manipulation:</p>
<pre><code class="language-go">func (c *applicationController) EndpointTransformers() restops.EndpointTransformers {
    openapi.AddTag(&quot;Applications&quot;, &quot;Configuration Applications Controller&quot;)
    
    return restops.EndpointTransformers{
        restops.AddEndpointPathPrefix(pathPrefixConfiguration),
        restops.AddEndpointTag(&quot;Applications&quot;),
    }
}
</code></pre>
<p>Current transformers are:</p>
<ul>
<li><code>AddEndpointTag</code>: Adds a tag to each endpoint</li>
<li><code>AddEndpointPathPrefix</code>: Adds a prefix to the path of each endpoint</li>
<li><code>AddEndpointErrorConverter</code>: Sets a custom ErrorConverter for each endpoint</li>
<li><code>AddEndpointErrorCoder</code>: Sets a custom ErrorCoder for each endpoint</li>
<li><code>AddEndpointContextInjector</code>: Adds a Context injector to each endpoint</li>
<li><code>AddEndpointMiddleware</code>: Adds an HTTP <a href="ops/restops/docs/middleware.html">Middleware</a> to each endpoint</li>
</ul>
<h3 id="endpointbuilder"><a class="header" href="#endpointbuilder"><code>EndpointBuilder</code></a></h3>
<p>Each endpoint in the controller can be generated using one of the provided <code>EndpointBuilder</code>
instances. go-msx provides builders for each active API style:</p>
<ul>
<li><strong>v2</strong>: Uses response envelopes and v2 pagination style</li>
<li><strong>v8</strong>: Uses no response envelopes, v8 error response format, and v8 pagination style</li>
</ul>
<h4 id="endpoint-types"><a class="header" href="#endpoint-types">Endpoint Types</a></h4>
<p>Each API style builder provides a number of different endpoint types:</p>
<ul>
<li>List: Return a series of entities matching a given criteria</li>
<li>Retrieve: Returns a single entity matching a primary key</li>
<li>Create: Instantiates a new entity using the supplied payload</li>
<li>Update: Replaces an existing entity using the supplied payload</li>
<li>Delete: Destroys an existing entity matching a primary key</li>
<li>Command: Executes an operation specific to the entity domain</li>
</ul>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<p>Here is an example (from lanservice) of a simple &quot;Command&quot; endpoint:</p>
<pre><code class="language-go">func (c *applicationController) applyConfiguration() restops.EndpointBuilder {
    type inputs struct {
        Id                types.UUID `req:&quot;path&quot;`
        IncludeSubTenants bool       `req:&quot;query&quot; required:&quot;false&quot; default:&quot;false&quot; description:&quot;Include Sub Tenants&quot;`
    }

    type outputs struct {
        Body api.ConfigurationResponse `resp:&quot;body&quot;`
    }

    return v2.
        NewCommandEndpointBuilder(pathSuffixConfigurationId, &quot;applications&quot;).
        WithId(&quot;applyConfigurationForTenant&quot;).
        WithInputs(inputs{}).
        WithOutputs(outputs{}).
        WithPermissions(permissionManageSwitchConfigurations).
        WithDoc(new(openapi3.Operation).
            WithSummary(&quot;Apply configuration to a tenant&quot;)).
        WithHandler(func (ctx context.Context, inp *inputs) (out outputs, err error) {
            out.Body, err = c.applicationService.
                ApplyConfiguration(ctx, inp.Id, inp.IncludeSubTenants)
            return
        })
}
</code></pre>
<p>Above, you can see a number of different components:</p>
<ul>
<li><strong><a href="ops/restops/docs/input-ports.html">input port structure</a></strong>: defines the fields to be retrieved from the request</li>
<li><strong><a href="ops/restops/docs/output-ports.html">output port structure</a></strong>: defines the fields to be applied to the response</li>
<li><strong>builder</strong>: simplifies creating endpoints
<ul>
<li><strong>operation name</strong>: defines the operation key in OpenApi and Tracing</li>
<li><strong>permissions</strong>: enumerates the possible passing permission(s)</li>
<li><strong>handler</strong>: called when the endpoint is activated</li>
<li><strong>documentation</strong>: populates the OpenApi documentation</li>
</ul>
</li>
</ul>
<h4 id="handler"><a class="header" href="#handler">Handler</a></h4>
<p>The Endpoint Handler accepts functions with arbitrary arguments, which it will fill out by
matching the argument type.  These can include:</p>
<ul>
<li><code>context.Context</code>: The context of the request</li>
<li><code>*http.Request</code>: The inbound HTTP request being handled, allowing for manual
request parsing</li>
<li><code>http.ResponseWriter</code>: The outbound HTTP response to return, allowing for manual
response handling</li>
<li><code>*inputs</code>: The Input Port structure declared by a call to <code>WithInputs</code>, containing the
populated inputs</li>
</ul>
<p>The Endpoint Handler also accepts functions with arbitrary return values, which it will 
consume:</p>
<ul>
<li><code>outputs</code>: The Output Port structure declared by a call to <code>WithOutputs</code>, which you
can populate with response outputs.</li>
<li><code>error</code>: An error to be applied to the defined (or style default) error response body.</li>
</ul>
<p>If the Output Port structure is excluded from the declaration of
your return values, you are expected to use an <code>http.ResponseWriter</code> to manually
send the success response (or return an <code>error</code>).</p>
<p>If both the Output Port structure <em>and</em> <code>error</code> are excluded, you are expected
to manually send a response (whether error or success).</p>
<h5 id="standard-practice"><a class="header" href="#standard-practice">Standard Practice</a></h5>
<p>The most common format for handler function includes context, inputs, outputs, and error:</p>
<pre><code class="language-go">    .WithHandler(
        func (ctx context.Context, inp *inputs) (out outputs, err error) {
            ...		
        })
</code></pre>
<h5 id="manual-handling"><a class="header" href="#manual-handling">Manual Handling</a></h5>
<p>To manually handle the request/response cycle, use a standard go HTTP handler:</p>
<pre><code class="language-go">    .WithHttpHandler(
        func (resp http.ResponseWriter, req *http.Request){
            ...
        })
</code></pre>
<h4 id="custom-validation"><a class="header" href="#custom-validation">Custom Validation</a></h4>
<p>Endpoint parameter validation can be performed in two ways:</p>
<ol>
<li>
<p>Define struct tags on each field declaring the jsonschema validation that is required. This
is used to validate the format of strings, enumerations, etc.</p>
</li>
<li>
<p>Any member of the <code>inputs</code> struct passed into <code>Endpoint.Inputs</code> which implement the <code>validate.Validatable</code> interface
will be validated before being passed into the controller. Create and Update request bodies with complex inter-field
interactions will typically use this. Common validators are provided by
the <a href="https://github.com/go-ozzo/ozzo-validation">github.com/go-ozzo/ozzo-validation</a> package.
A few custom validators are available in the <a href="ops/restops/docs/../validate/README.html">validate</a> package.</p>
</li>
</ol>
<p>Any non-nil errors returned by the validation function will cause an instance of <code>ValidationErrors</code>
to be sent back to the client (with a 400 Bad Request header) detailing the errors.</p>
<h4 id="response-codes"><a class="header" href="#response-codes">Response Codes</a></h4>
<h5 id="success-responses"><a class="header" href="#success-responses">Success Responses</a></h5>
<p>To use the default success status code (determined by which builder you used), no implementation is required.
To override the success code, add a <code>Code int resp:&quot;code&quot;</code> field to your output port struct
and populate it before returning from your handler.</p>
<h5 id="error-responses"><a class="header" href="#error-responses">Error Responses</a></h5>
<p>REST operations have built-in default error coder, which you can override using a custom error
mapper or error coder.</p>
<p>Default mappings include:</p>
<div class="table-wrapper"><table><thead><tr><th>Error</th><th>Code</th></tr></thead><tbody>
<tr><td><code>js.ErrValidationFailed</code></td><td>400</td></tr>
<tr><td><code>ops.ErrMissingRequiredValue</code></td><td>400</td></tr>
<tr><td><code>rbac.ErrTenantDoesNotExist</code></td><td>401</td></tr>
<tr><td><code>rbac.ErrUserDoesNotHaveTenantAccess</code></td><td>401</td></tr>
<tr><td><code>repository.ErrAlreadyExists</code></td><td>409</td></tr>
<tr><td><code>repository.ErrNotFound</code></td><td>404</td></tr>
</tbody></table>
</div>
<h2 id="lifecycle-registration-1"><a class="header" href="#lifecycle-registration-1">Lifecycle Registration</a></h2>
<p>In order to instantiate your controller during application startup, you can register a simple
<code>init</code> function:</p>
<pre><code class="language-go">func init() {
    app.OnCommandsEvent(
        []string{
            app.CommandRoot,
            app.CommandOpenApi,
        },
        app.EventStart,
        app.PhaseBefore,
        func (ctx context.Context) error {
            controller, err := newApplicationController(ctx)
            if err != nil {
                return err
            }
            
            return restops.
                ContextEndpointRegisterer(ctx).
                RegisterEndpoints(controller)
        })	
}
</code></pre>
<p>This will register your controller during normal microservice startup, as well as
during OpenApi spec generation.</p>
<p>To ensure your module is included in the built microservice, include the module from your <code>main.go</code>:</p>
<pre><code class="language-go">import _ &quot;cto-github.cisco.com/NFV-BU/lanservice/internal/application&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-input-ports"><a class="header" href="#rest-input-ports">REST Input Ports</a></h1>
<p>As described in <a href="ops/restops/docs/../../docs/input-ports.html">Input Ports</a>, an Input Port is a go structure used to describe
a source payload to be parsed, such as an HTTP REST API Request.</p>
<p>Each field in the Input Port structure is expected to have a <code>req</code> struct tag. Any fields
missing this tag will be ignored by the input populator.</p>
<p>The structure includes any required or optional parameters (Cookies,
Form, Headers, Path, Query), along with any expected body content.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<p>The following example shows a simple Create API input port definition:</p>
<pre><code class="language-go">type createEntityInputs struct {
    ControlPlaneId types.UUID              `req:&quot;path&quot;`
    Payload        api.CreateEntityRequest `req:&quot;body&quot;`
}
</code></pre>
<p>In this example, <code>ControlPlaneId</code> is expected to be found in the path (with the default
path parameter style, <code>controlPlaneId</code>). The body is expected to contain a JSON-serialized
instance of <code>api.CreateEntityRequest</code>.</p>
<h3 id="field-groups"><a class="header" href="#field-groups">Field Groups</a></h3>
<p>The possible field groups used by the <code>req</code> struct tag are:</p>
<ul>
<li><strong>method</strong>: The HTTP method</li>
<li><strong>header</strong>: An HTTP header</li>
<li><strong>cookie</strong>: An sub-entry from the Cookie header </li>
<li><strong>path</strong>: A segment of the path</li>
<li><strong>query</strong>: A query parameter</li>
<li><strong>form</strong>: A form field</li>
<li><strong>body</strong>: The body content</li>
</ul>
<h3 id="field-index"><a class="header" href="#field-index">Field Index</a></h3>
<p>Each field will typically have a group (source) and index (key).
You will recall the format of the <code>req</code> tag:</p>
<pre><code>req:&quot;&lt;fieldGroup&gt;[=&lt;fieldIndex&gt;]&quot;
</code></pre>
<p>Most field indices default to the lowerCamelCase inflection of the field name.
The only exception is for headers, which are the Upper-Kebab-Case inflection
of the field name by default.</p>
<p>Non-indexed fields such as <code>method</code> and <code>body</code> do not accept a field index, and
they will be ignored if specified; there is only one of each of these in any request.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-output-ports"><a class="header" href="#rest-output-ports">REST Output Ports</a></h1>
<p>As described in <a href="ops/restops/docs/../../docs/output-ports.html">Output Ports</a>, an Output Port is a go structure 
used to describe a destination payload to be generated, such as an HTTP REST API Response.
An Output port is the Response equivalent of an Input Port, and follows many of the same
rules and patterns.</p>
<p>Each field in the Output Port structure is expected to have a <code>resp</code> struct tag. Any fields
missing this tag will be ignored by the output populator.</p>
<p>The structure includes any required or optional results, including status code, headers,
paging, and success and/or error bodies.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<p>The following example shows a simple Create API output port definition:</p>
<pre><code class="language-go">type createEntityInputs struct {
    Payload        api.CreateEntityResponse `resp:&quot;body&quot;`
}
</code></pre>
<p>The response body will be populated with a JSON-serialized instance of <code>api.CreateEntityResponse</code>.</p>
<h3 id="field-groups-1"><a class="header" href="#field-groups-1">Field Groups</a></h3>
<p>The possible field groups used by the <code>resp</code> struct tag are:</p>
<ul>
<li><strong>code</strong>: The HTTP status code for the response</li>
<li><strong>header</strong>: </li>
<li><strong>paging</strong>: An envelope wrapping the body containing the paging response</li>
<li><strong>body</strong>: The primary payload of the response (excluding any envelopes/paging).
You may also specify <code>success:&quot;true&quot;</code> or <code>error:&quot;true&quot;</code> to define multiple
potential bodies.</li>
</ul>
<h3 id="field-index-1"><a class="header" href="#field-index-1">Field Index</a></h3>
<p>Each header field will have a group (source) and index (key).
You will recall the format of the <code>resp</code> tag:</p>
<pre><code>resp:&quot;&lt;fieldGroup&gt;[=&lt;fieldIndex&gt;]&quot;
</code></pre>
<p>Header field indices default to the Upper-Kebab-Case inflection of the field name 
by default.</p>
<p>Non-indexed fields such as <code>code</code> and <code>body</code> do not accept a field index, and
they will be ignored if specified; there is only one of each of these in any 
generated response.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware-1"><a class="header" href="#middleware-1">Middleware</a></h1>
<p>You can use a Mediator/Middleware component to augment the functionality of 
go-msx components such as endpoints:</p>
<blockquote>
<p>Middleware is software that's assembled into an app pipeline to handle requests and responses.
Each component:</p>
<ul>
<li>chooses whether to pass execution to the next component in the pipeline.</li>
<li>can perform work before and after the next component in the pipeline.</li>
</ul>
<p>-- <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x&amp;view=aspnetcore-7.0">ASP.NET Core Middleware</a>, Microsoft</p>
</blockquote>
<p>Go HTTP Middleware factories implement a de facto function signature:</p>
<pre><code class="language-go">type Middleware func(next http.Handler) http.Handler

func myMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Middleware BEFORE logic goes here...
        next.ServeHTTP(w, r)
        // Middleware AFTER logic goes here...
    })
}
</code></pre>
<p>The factory accepts the subsequent Handler in the middleware chain, and returns a new
Handler which wraps it with the desired added functionality.  You can find more details and
examples on <a href="https://www.alexedwards.net/blog/making-and-using-middleware">this blog post</a>.</p>
<h2 id="available-http-middleware"><a class="header" href="#available-http-middleware">Available HTTP Middleware</a></h2>
<p>go-msx does not currently define any HTTP Middleware, however there are many libraries available,
including:</p>
<ul>
<li><a href="https://github.com/gorilla/handlers">github.com/gorilla/handlers</a></li>
<li><a href="https://github.com/throttled/throttled">github.com/throttled/throttled/v2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-database-repository"><a class="header" href="#sql-database-repository">SQL Database Repository</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Repository is to query and mutate the persistent storage of Models.</p>
<h2 id="defining-the-repository"><a class="header" href="#defining-the-repository">Defining the Repository</a></h2>
<p>To define a repository, create a standard Go structure with an anonymous field for the CrudRepository:</p>
<pre><code class="language-go">type deviceSqlRepository struct {
    sqldb.CrudRepositoryApi
}
</code></pre>
<p>The <code>CrudRepositoryApi</code> object provides access to the SQL database underneath using generic objects 
and slices.</p>
<h2 id="writing-a-constructor"><a class="header" href="#writing-a-constructor">Writing a Constructor</a></h2>
<p>A standard repository constructor allows for dependency injection (during testing) and normal creation (during runtme):</p>
<pre><code class="language-go">func newDeviceRepository(ctx context.Context) deviceRepositoryApi {
	repo := deviceRepositoryFromContext(ctx)
	if repo == nil {
		repo = &amp;deviceSqlRepository{
			CrudRepositoryApi: sqldb.
				CrudRepositoryFactoryFromContext(ctx).
				NewCrudRepository(&quot;device&quot;),
		}
	}
	return repo
}
</code></pre>
<ul>
<li>The <code>CrudRepositoryFactory</code> allows us to test the repository without requiring an actual database implementation.</li>
<li>The <code>deviceRepositoryFromContext</code> allows us to test this repositories reverse-dependencies without requiring
an actual <code>deviceSqlRepository</code>.</li>
</ul>
<h2 id="implementing-common-access-methods"><a class="header" href="#implementing-common-access-methods">Implementing Common Access Methods</a></h2>
<p>A basic repository will likely have the following common methods:</p>
<ul>
<li><code>FindAll</code>
<ul>
<li>Retrieve all models</li>
</ul>
</li>
<li><code>FindByKey</code>
<ul>
<li>Retrieve a single model by its primary key</li>
</ul>
</li>
<li><code>Save</code>
<ul>
<li>Store a single model</li>
</ul>
</li>
<li><code>Delete</code>
<ul>
<li>Remove a single model</li>
</ul>
</li>
</ul>
<p>More advanced repositories may have some less-common methods:</p>
<ul>
<li><code>FindAllByIndexXXX</code>
<ul>
<li>Retrieve all models matching the specified criteria using an index</li>
</ul>
</li>
<li><code>FindAllPagedBy</code>
<ul>
<li>Retrieve a subset of models matching the specified criteria, using the specified sorting and pagination</li>
</ul>
</li>
<li><code>Truncate</code>
<ul>
<li>Remove all models</li>
</ul>
</li>
</ul>
<h3 id="findall"><a class="header" href="#findall">FindAll</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) FindAll(ctx context.Context) (results []device, err error) {
	logger.WithContext(ctx).Info(&quot;Retrieving all Device records&quot;)
	err = r.CrudRepositoryApi.FindAll(ctx, &amp;results)
	return
}
</code></pre>
<ol>
<li>Log method intention</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.</li>
</ol>
<h3 id="findbykey"><a class="header" href="#findbykey">FindByKey</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) FindByKey(ctx context.Context, name string) (result *device, err error) {
	logger.WithContext(ctx).Infof(&quot;Retrieving Device by key %q&quot;, name)
	var res device
	err = r.CrudRepositoryApi.FindOneBy(ctx, map[string]interface{}{
		&quot;name&quot;: name,
	}, &amp;res)
	if err == sqldb.ErrNotFound {
		err = repository.ErrNotFound
	} else if err == nil {
		result = &amp;res
	}
	return
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.FindOneBy</code> method accepts a map of criteria to search by -- 
in this case, the primary key.</li>
</ul>
</li>
<li>Normalize the <code>sqldb</code> error code to use <code>repository</code> error codes.</li>
</ol>
<h3 id="save"><a class="header" href="#save">Save</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) Save(ctx context.Context, device device) (err error) {
	logger.WithContext(ctx).Infof(&quot;Storing Device with key %q&quot;, device.Name)
	return r.CrudRepositoryApi.Save(ctx, device)
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record storage and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.Save</code> method performs an <code>UPSERT</code> query in Cockroach so it behaves
in much the same way as the <code>Save</code> method from a KV repository.</li>
</ul>
</li>
</ol>
<h3 id="delete"><a class="header" href="#delete">Delete</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) Delete(ctx context.Context, name string) (err error) {
	logger.WithContext(ctx).Infof(&quot;Deleting Device by key %q&quot;, name)
	return r.CrudRepositoryApi.DeleteBy(ctx, map[string]interface{}{
		columnDeviceName: name,
	})
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.DeleteBy</code> method accepts a map of criteria to delete by -- 
in this case, the primary key.</li>
</ul>
</li>
</ol>
<h3 id="transaction-support"><a class="header" href="#transaction-support">Transaction Support</a></h3>
<pre><code class="language-go">    err := sqldb.NewTransactionManager().
        WithTransaction(ctx, func(ctx context.Context) error {
            // do all your db processes in here (preferably prepared)

            // then return nil to commit or an error to rollback
            // return errors.New(&quot;some error&quot;) // to rollback
            return nil // to commit
        })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typedrepository"><a class="header" href="#typedrepository">TypedRepository</a></h1>
<p><strong>TypedRepository</strong> should be the most used going forward and it should be able to cater to most repository needs. It is most encouraged to use this repository.</p>
<p>If developers feel there are anything missing or things that can be improved on (specially if you feel you still need to use any repo aside from TypedRepository) please reach out to the #go-msx team.</p>
<h3 id="insert"><a class="header" href="#insert">Insert</a></h3>
<pre><code>err = personsRepo.Insert(ctx, person1)
</code></pre>
<h3 id="upsert"><a class="header" href="#upsert">Upsert</a></h3>
<pre><code>err = personsRepo.Upsert(ctx, person1)
</code></pre>
<h3 id="update"><a class="header" href="#update">Update</a></h3>
<pre><code>err = personsRepo.Update(ctx, goqu.Ex(map[string]interface{}{&quot;id&quot;: person1.Id}), person1)
</code></pre>
<h3 id="countall"><a class="header" href="#countall">CountAll</a></h3>
<pre><code>err = personsRepo.CountAll(ctx, &amp;count, nil)
</code></pre>
<h3 id="findone"><a class="header" href="#findone">FindOne</a></h3>
<pre><code>err = personsRepo.FindOne(ctx, &amp;destPerson, sqldb.And(map[string]interface{}{&quot;id&quot;: person1.Id}).Expression())
</code></pre>
<h3 id="findall-1"><a class="header" href="#findall-1">FindAll</a></h3>
<pre><code>pagingResponse, err := personsRepo.FindAll(ctx, &amp;destPersons,
	sqldb.Where(goqu.Ex(map[string]interface{}{&quot;name&quot;: person1.Name})),
	sqldb.Keys(goqu.Ex(map[string]interface{}{&quot;id&quot;: person1.Id})),
	sqldb.Distinct(&quot;name&quot;),
	sqldb.Sort([]paging.SortOrder{paging.SortOrder{Property: &quot;name&quot;, Direction: &quot;ASC&quot;}}),
	sqldb.Paging(paging.Request{Size: 10, Page: 0}),
)
</code></pre>
<h3 id="deleteone"><a class="header" href="#deleteone">DeleteOne</a></h3>
<pre><code>err = personsRepo.DeleteOne(ctx, goqu.Ex(map[string]interface{}{&quot;id&quot;: person1.Id}))
</code></pre>
<h3 id="deleteall"><a class="header" href="#deleteall">DeleteAll</a></h3>
<pre><code>err = personsRepo.DeleteAll(ctx, goqu.Ex(map[string]interface{}{&quot;name&quot;: person1.Name}))
</code></pre>
<h3 id="truncate"><a class="header" href="#truncate">Truncate</a></h3>
<pre><code>err = personsRepo.Truncate(ctx)
</code></pre>
<br />
<h2 id="complete-code-examples"><a class="header" href="#complete-code-examples">Complete Code Examples</a></h2>
<p>First create the persons table in order for the sample codes below to work.</p>
<p><code>CREATE TABLE persons ( id UUID PRIMARY KEY, name STRING );</code></p>
<pre><code>type Person struct {
    Id uuid.UUID `db:&quot;id&quot;`
    Name string `db:&quot;name&quot;`
}

personsRepo, err := sqldb.NewTypedRepository[Person](ctx, &quot;persons&quot;)
if err != nil {
	logger.WithContext(ctx).Error(err)
}

person1 := Person{Id: uuid.MustParse(&quot;437f96b0-6722-11ed-9022-0242ac120009&quot;), Name: &quot;Jonee&quot;}
err = personsRepo.Insert(ctx, person1)
if err != nil {
	logger.WithContext(ctx).Error(err)
}

person1.Name = &quot;Jonee6&quot;
err = personsRepo.Upsert(ctx, person1)
if err != nil {
	logger.WithContext(ctx).Error(err)
}

person1.Name = &quot;Jonee7&quot;
err = personsRepo.Update(ctx, goqu.Ex(map[string]interface{}{&quot;id&quot;: person1.Id}), person1)
if err != nil {
	logger.WithContext(ctx).Error(err)
}

count := int64(0)
err = personsRepo.CountAll(ctx, &amp;count, nil)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(count)

var destPerson Person
err = personsRepo.FindOne(ctx, &amp;destPerson, sqldb.And(map[string]interface{}{&quot;id&quot;: person1.Id}).Expression())
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(destPerson)

var destPersons []Person
pagingResponse, err := personsRepo.FindAll(ctx, &amp;destPersons,
	sqldb.Where(goqu.Ex(map[string]interface{}{&quot;name&quot;: person1.Name})),
	sqldb.Keys(goqu.Ex(map[string]interface{}{&quot;id&quot;: person1.Id})),
	sqldb.Distinct(&quot;name&quot;),
	sqldb.Sort([]paging.SortOrder{paging.SortOrder{Property: &quot;name&quot;, Direction: &quot;ASC&quot;}}),
	sqldb.Paging(paging.Request{Size: 10, Page: 0}),
)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(pagingResponse)
logger.WithContext(ctx).Info(destPersons)

err = personsRepo.DeleteOne(ctx, goqu.Ex(map[string]interface{}{&quot;id&quot;: person1.Id}))
if err != nil {
	logger.WithContext(ctx).Error(err)
}

err = personsRepo.DeleteAll(ctx, goqu.Ex(map[string]interface{}{&quot;name&quot;: person1.Name}))
if err != nil {
	logger.WithContext(ctx).Error(err)
}

err = personsRepo.Truncate(ctx)
if err != nil {
	logger.WithContext(ctx).Error(err)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goqurepository"><a class="header" href="#goqurepository">GoquRepository</a></h1>
<p><strong>GoquRepository</strong> is for those who may want more flexibility (that otherwise TypedRepository cannot provide) and would like to work on the Goqu level.</p>
<p>If developers feel there are anything missing or things that can be improved on (specially if you feel you still need to use any repo aside from TypedRepository) please reach out to the #go-msx team.</p>
<h3 id="insert-1"><a class="header" href="#insert-1">Insert</a></h3>
<pre><code>dsInsert := rgoqu.Insert(&quot;persons&quot;)

err = rgoqu.ExecuteInsert(ctx, dsInsert.Rows(person2))
</code></pre>
<h3 id="upsert-1"><a class="header" href="#upsert-1">Upsert</a></h3>
<pre><code>dsUpsert := rgoqu.Upsert(&quot;persons&quot;)

err = rgoqu.ExecuteUpsert(ctx, dsUpsert.Rows(person2))
</code></pre>
<h3 id="update-1"><a class="header" href="#update-1">Update</a></h3>
<pre><code>dsUpdate := rgoqu.Update(&quot;persons&quot;)

err = rgoqu.ExecuteUpdate(ctx, dsUpdate.Where(goqu.Ex(map[string]interface{}{&quot;id&quot;: person2.Id})).Set(person2))
</code></pre>
<h3 id="get"><a class="header" href="#get">Get</a></h3>
<pre><code>dsGet := rgoqu.Get(&quot;persons&quot;)

err = rgoqu.ExecuteGet(ctx, dsGet.Where(goqu.Ex(map[string]interface{}{&quot;id&quot;: person2.Id})), &amp;destPerson2)
</code></pre>
<h3 id="select"><a class="header" href="#select">Select</a></h3>
<pre><code>dsSelect := rgoqu.Select(&quot;persons&quot;)

err = rgoqu.ExecuteSelect(ctx, dsSelect.Where(goqu.Ex(map[string]interface{}{&quot;name&quot;: person2.Name})), &amp;destPersons2)
</code></pre>
<h3 id="delete-1"><a class="header" href="#delete-1">Delete</a></h3>
<pre><code>dsDelete := rgoqu.Delete(&quot;persons&quot;)

err = rgoqu.ExecuteDelete(ctx, dsDelete.Where(goqu.Ex(map[string]interface{}{&quot;id&quot;: person2.Id})))
</code></pre>
<h3 id="truncate-1"><a class="header" href="#truncate-1">Truncate</a></h3>
<pre><code>dsTruncate := rgoqu.Truncate(&quot;persons&quot;)

err = rgoqu.ExecuteTruncate(ctx, dsTruncate)
</code></pre>
<br />
<h2 id="complete-code-examples-1"><a class="header" href="#complete-code-examples-1">Complete Code Examples</a></h2>
<p>First create the persons table in order for the sample codes below to work.</p>
<p><code>CREATE TABLE persons ( id UUID PRIMARY KEY, name STRING );</code></p>
<pre><code>type Person struct {
    Id uuid.UUID `db:&quot;id&quot;`
    Name string `db:&quot;name&quot;`
}

rgoqu, err := sqldb.NewGoquRepository(ctx)
if err != nil {
	logger.WithContext(ctx).Error(err)
}

person2 := Person{Id: uuid.MustParse(&quot;437f96b0-6722-11ed-9022-0242ac120005&quot;), Name: &quot;Jonee&quot;}

dsInsert := rgoqu.Insert(&quot;persons&quot;)

err = rgoqu.ExecuteInsert(ctx, dsInsert.Rows(person2))
if err != nil {
	logger.WithContext(ctx).Error(err)
}


dsUpsert := rgoqu.Upsert(&quot;persons&quot;)

person2.Name = &quot;Jonee6&quot;
err = rgoqu.ExecuteUpsert(ctx, dsUpsert.Rows(person2))
if err != nil {
	logger.WithContext(ctx).Error(err)
}


dsUpdate := rgoqu.Update(&quot;persons&quot;)

person2.Name = &quot;Jonee7&quot;
err = rgoqu.ExecuteUpdate(ctx, dsUpdate.Where(goqu.Ex(map[string]interface{}{&quot;id&quot;: person2.Id})).Set(person2))
if err != nil {
	logger.WithContext(ctx).Error(err)
}


var destPerson2 Person
dsGet := rgoqu.Get(&quot;persons&quot;)

err = rgoqu.ExecuteGet(ctx, dsGet.Where(goqu.Ex(map[string]interface{}{&quot;id&quot;: person2.Id})), &amp;destPerson2)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(destPerson2)


var destPersons2 []Person
dsSelect := rgoqu.Select(&quot;persons&quot;)

err = rgoqu.ExecuteSelect(ctx, dsSelect.Where(goqu.Ex(map[string]interface{}{&quot;name&quot;: person2.Name})), &amp;destPersons2)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(destPersons2)


dsDelete := rgoqu.Delete(&quot;persons&quot;)

err = rgoqu.ExecuteDelete(ctx, dsDelete.Where(goqu.Ex(map[string]interface{}{&quot;id&quot;: person2.Id})))
if err != nil {
	logger.WithContext(ctx).Error(err)
}


dsTruncate := rgoqu.Truncate(&quot;persons&quot;)

err = rgoqu.ExecuteTruncate(ctx, dsTruncate)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqlrepository"><a class="header" href="#sqlrepository">SqlRepository</a></h1>
<p><strong>SqlRepository</strong> is offered for those who may need to go down to the SQL level. 
This may be hard to maintain and inflexible (might be error-prone too) and thus discouraged as much as possible.</p>
<p>If developers feel there are anything missing or things that can be improved on (specially if you feel you still need to use any repo aside from TypedRepository) please reach out to the #go-msx team.</p>
<h3 id="sqlexecute"><a class="header" href="#sqlexecute">SqlExecute</a></h3>
<pre><code>err = rsql.SqlExecute(ctx, &quot;INSERT INTO persons VALUES ($1, $2)&quot;, []interface{}{uuid.MustParse(&quot;437f96b0-6722-11ed-9022-0242ac120002&quot;), &quot;Jonee&quot;})
</code></pre>
<h3 id="sqlselect"><a class="header" href="#sqlselect">SqlSelect</a></h3>
<pre><code>var destPersons3 []Person
err = rsql.SqlSelect(ctx, &quot;SELECT * FROM persons&quot;, nil, &amp;destPersons3)
</code></pre>
<h3 id="sqlget"><a class="header" href="#sqlget">SqlGet</a></h3>
<pre><code>var destPerson3 Person
err = rsql.SqlGet(ctx, &quot;SELECT * FROM persons WHERE id=$1&quot;, []interface{}{uuid.MustParse(&quot;437f96b0-6722-11ed-9022-0242ac120002&quot;)}, &amp;destPerson3)
</code></pre>
<br />
<h2 id="complete-code-examples-2"><a class="header" href="#complete-code-examples-2">Complete Code Examples</a></h2>
<p>First create the persons table in order for the sample codes below to work.</p>
<p><code>CREATE TABLE persons ( id UUID PRIMARY KEY, name STRING );</code></p>
<pre><code>type Person struct {
    Id uuid.UUID `db:&quot;id&quot;`
    Name string `db:&quot;name&quot;`
}

rsql, err := sqldb.NewSqlRepository(ctx)
if err != nil {
	logger.WithContext(ctx).Error(err)
}

err = rsql.SqlExecute(ctx, &quot;INSERT INTO persons VALUES ($1, $2)&quot;, []interface{}{uuid.MustParse(&quot;437f96b0-6722-11ed-9022-0242ac120002&quot;), &quot;Jonee&quot;})
if err != nil {
	logger.WithContext(ctx).Error(err)
}

var destPersons3 []Person
err = rsql.SqlSelect(ctx, &quot;SELECT * FROM persons&quot;, nil, &amp;destPersons3)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(destPersons3)

var destPerson3 Person
err = rsql.SqlGet(ctx, &quot;SELECT * FROM persons WHERE id=$1&quot;, []interface{}{uuid.MustParse(&quot;437f96b0-6722-11ed-9022-0242ac120002&quot;)}, &amp;destPerson3)
if err != nil {
	logger.WithContext(ctx).Error(err)
}
logger.WithContext(ctx).Info(destPerson3)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openapi-client"><a class="header" href="#openapi-client">OpenApi Client</a></h1>
<p>MSX enables generating OpenApi clients with ease.</p>
<h2 id="client-generation"><a class="header" href="#client-generation">Client Generation</a></h2>
<p>The following snippets show an example of how to generate an OpenApi client
for Manage Microservice V8 APIs:</p>
<ul>
<li>
<p><code>cmd/build/build.yml</code>:</p>
<pre><code class="language-yaml"># Integration Generation
generate:
  - path: internal/integration/manage
    openapi:
      spec: ../.openapi/manage-service-8.yaml
      config: ../.openapi/manage-service-8-config.json
</code></pre>
</li>
<li>
<p><code>internal/integration/.openapi/manage-service-8.yaml</code>:
Place the openapi contract in this file.</p>
</li>
<li>
<p><code>internal/integration/.openapi/manage-service-8-config.json</code>:</p>
<pre><code class="language-json">{
  &quot;generateInterfaces&quot;: true,
  &quot;structPrefix&quot;: false,
  &quot;packageName&quot;: &quot;manage&quot;,
  &quot;enablePostProcessFile&quot;: true
}
</code></pre>
</li>
<li>
<p><code>internal/integration/manage/.openapi-generator-ignore</code></p>
<pre><code>.gitignore
go.mod
go.sum
.openapi-generator-ignore
.travis.yml
api/**
docs/**
git_push.sh
</code></pre>
</li>
</ul>
<p>After the above pieces are in place, you can execute the generate build step:</p>
<pre><code class="language-bash">make generate
</code></pre>
<h2 id="contract-validation"><a class="header" href="#contract-validation">Contract Validation</a></h2>
<p>To ensure the upstream contract remains compatible with your local version:</p>
<ol>
<li>
<p>Add the following snippet to <code>build.yml</code>:</p>
<pre><code class="language-yaml"># Contract Management
openapi:
  # Remote (consumer) API contract pairs
  contracts:
    - consumer: internal/integration/.openapi/manage-service-8.yaml
      producer: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/develop/manage-service-8.yaml

  # Sources for well-known schemas
  alias:
    - from: https://api.swaggerhub.com/domains/Cisco-Systems46/msx-common-domain/8
      to: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/sdk1.0.10/common-domain-8.yaml
</code></pre>
<p>Any internal GitHub links will use the GitHub Personal Access Token from your environment
(<code>GITHUB_TOKEN</code>) when retrieving the file.  Ensure you have an up-to-date PAT configured.</p>
</li>
<li>
<p>Add a check to your <code>build/ci/checks.yml</code>:</p>
<pre><code class="language-yaml">checks:
  - name: OpenApi
    commands:
      - make: openapi-compare
    analyzers:
      - builtin: generate-openapi-report
</code></pre>
<p>This will ensure each commit to your repo checks for backwards-incompatible changes to 
the contract.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-stream-operations"><a class="header" href="#msx-stream-operations">MSX Stream Operations</a></h1>
<p>A Streaming Operation library compatible with <a href="https://asyncapi.com">AsyncApi</a> 2.x documentation.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>Message
: A discrete unit of communication between a publisher and
a set of subscribers. Must include data (payload) and may
include metadata (headers).</p>
<p>Channel
: A source or destination for message delivery between
publishers and subscribers.</p>
<p>Subscriber
: A receiver of a sequence of messages from a channel.</p>
<p>Publisher
: A sender of a sequence of messages to a channel.</p>
<p>AsyncApi
: Documentation standard for describing event-based and streaming
message transports such as Kafka, Redis Streams, Amazon SQS.
Describes messages, channels, publishers, subscribers, servers,
security, and other related concerns.  Comparable to OpenApi, which
describes REST message transports.</p>
<p>DTO
: Data Transfer Object.  Used for serialization and deserialization of
externally sourced or directed structured values.</p>
<p>Port
: Description of the interface between the Stream Operations subsystem and
your message publisher or subscriber. Can include headers, filters, and
must include a payload DTO.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The following table compares the pattern of components across AsyncApi,
Stream Operations, and HTTP components.</p>
<div class="table-wrapper"><table><thead><tr><th>AsyncApi</th><th>Stream Publisher</th><th>Stream Subscriber</th><th>HTTP</th><th>Purpose</th></tr></thead><tbody>
<tr><td>Channel</td><td>Channel</td><td>Channel</td><td>Controller</td><td>Domain ingress and egress</td></tr>
<tr><td>Operation</td><td>ChannelPublisher</td><td>ChannelSubscriber</td><td>Router</td><td>Dispatch to endpoints</td></tr>
<tr><td>Message</td><td>MessagePublisher</td><td>MessageSubscriber</td><td>Endpoint</td><td>Event processing</td></tr>
<tr><td>Header, Payload</td><td>Output Port</td><td>Input Port</td><td>Request/Response</td><td>Exchanged data</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="stream-ports"><a class="header" href="#stream-ports">Stream Ports</a></h1>
<p>Stream Ports are structures used to describe the parts of incoming and outgoing Stream Messages.
For an introduction to Ports, please see <a href="ops/streamops/../docs/ports.html">Ports</a>.</p>
<h2 id="input-ports-1"><a class="header" href="#input-ports-1">Input Ports</a></h2>
<p>Input Ports specify fields to be extracted from an incoming stream message or HTTP request.</p>
<p>Stream Input Port struct tags must use the <code>in</code> prefix.</p>
<p>Each field with an <code>in</code> struct tag will be automatically populated before being
passed to your Message Subscriber.  The full syntax of the <code>in</code> struct tag is as
follows:</p>
<pre><code>in:&quot;&lt;fieldGroup&gt;[=&lt;peerName&gt;]&quot;
</code></pre>
<p>The <code>in</code> struct tag contains the following subcomponents:</p>
<p><code>&lt;fieldGroup&gt;</code>
: (Required) The name of the message part from which the value will be extracted.
Valid field groups for streaming operations are:</p>
<ul>
<li><code>header</code> - Message metadata/headers (string-keyed map of strings).</li>
<li><code>body</code> - Message payload (JSON request body).  Max one per port struct.</li>
<li><code>messageId</code> - Unique id of the message (typically a random uuid)</li>
</ul>
<p><code>[=&lt;peerName&gt;]</code>
: (Optional)
A <em>peer</em> is the index within the field group of the data for each port field in the original message.
Currently, only <code>header</code> fieldGroup has indexed content (individual header values).
When not specified, the default peer in the metadata is the lowerCamelCase inflection of the field name: 
eg the <code>EventType</code> struct field points to the header <code>eventType</code>. </p>
<h2 id="output-ports-1"><a class="header" href="#output-ports-1">Output Ports</a></h2>
<p>Output ports specify parts of the published message to be populated from the
port struct.</p>
<p>Stream Output Port struct tags must use the <code>out</code> prefix.</p>
<p>Each field with an <code>out</code> struct tag will be automatically applied to the message
before the message is published.  The full syntax of the <code>out</code> struct tag is as
follows:</p>
<pre><code>out:&quot;&lt;fieldGroup&gt;[=peerName]&quot;
</code></pre>
<p>The subcomponents of the <code>out</code> struct tag are the same as <code>in</code> struct tag, above.</p>
<h2 id="data-transfer-objects-dtos"><a class="header" href="#data-transfer-objects-dtos">Data Transfer Objects (DTOs)</a></h2>
<p>Fields in a port specifying the <code>body</code> component will typically have a DTO struct
as their underlying type (eg. <code>api.DriftCheckRequest</code> above).</p>
<p>By default, these are serialized using the Content-Type of the stream 
(currently defaults to <code>application/json</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishers"><a class="header" href="#publishers">Publishers</a></h1>
<p>Stream Operations Publishers are used to publish messages on streams. 
They consist of a number of components:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>AsyncApi Documentor</th><th>Documentation Model</th></tr></thead><tbody>
<tr><td>Your Message Publisher (service)</td><td>-</td><td>-</td></tr>
<tr><td>Your Output Port (struct)</td><td>asyncapi.MessagePublisherDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>Your Payload DTO (struct)</td><td>asyncapi.MessagePublisherDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>streamops.MessagePublisher</td><td>asyncapi.MessagePublisherDocumentor</td><td>asyncapi.Message</td></tr>
<tr><td>streamops.ChannelPublisher</td><td>asyncapi.ChannelPublisherDocumentor</td><td>asyncapi.Operation</td></tr>
<tr><td>streamops.Channel</td><td>asyncapi.ChannelDocumentor</td><td>asyncapi.Channel</td></tr>
</tbody></table>
</div>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<p><strong>Channel</strong></p>
<p>The channel component represents the stream itself (SQS or Kafka topic, Redis stream, Go channel, SQLDB table, etc).
It is implemented as a singleton that should be created after configuration but before start-up.</p>
<p><strong>Channel Publisher</strong></p>
<p>The channel publisher component represents the set of publishable messages for a given stream.
It is implemented as a service that should be created as a dependency of your message publisher.</p>
<p><strong>Message Publisher</strong></p>
<p>The message publisher component represents one of the publishable messages for a given stream.
It is implemented as a service created after configuration but before start-up.<br />
Notice that it has a defined API interface for mocking, and should be mocked by dependent services
during testing.</p>
<p><strong>Output Port</strong></p>
<p>The message port contains a mapping of fields to be set on the outgoing message.
Each field will be mapped to a header or body field based on the struct tags.</p>
<p><strong>Message Payload DTO</strong></p>
<p>The payload DTO will contain the body of message that is to be published.
Before dispatch to the underlying stream, the message will be validated using
the JSON-schema annotations on your DTO.</p>
<h2 id="generation"><a class="header" href="#generation">Generation</a></h2>
<p>It is strongly advised to auto-generate these components and customize them afterwards.
See <a href="ops/streamops/../../skel/asyncapi/channels.html">Channels</a> and <a href="ops/streamops/../../skel/asyncapi/spec.html">AsyncApi</a>
for details about generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscribers"><a class="header" href="#subscribers">Subscribers</a></h1>
<p>Stream Operations Subscribers are used to publish messages on streams.
They consist of a number of components:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>AsyncApi Documentor</th><th>Documentation Model</th></tr></thead><tbody>
<tr><td>Your Message Subscriber (service)</td><td>-</td><td>-</td></tr>
<tr><td>Your Input Port (struct)</td><td>asyncapi.MessageSubscriberDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>Your Payload DTO (struct)</td><td>asyncapi.MessageSubscriberDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>streamops.MessageSubscriber</td><td>asyncapi.MessageSubscriberDocumentor</td><td>asyncapi.Message</td></tr>
<tr><td>streamops.ChannelSubscriber</td><td>asyncapi.ChannelSubscriberDocumentor</td><td>asyncapi.Operation</td></tr>
<tr><td>streamops.Channel</td><td>asyncapi.ChannelDocumentor</td><td>asyncapi.Channel</td></tr>
</tbody></table>
</div>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<p><strong>Channel</strong></p>
<p>The channel component represents the stream itself (SQS or Kafka topic, Redis stream, Go channel, SQLDB table, etc).
It is implemented as a singleton that should be created after configuration but before start-up.</p>
<p><strong>Channel Subscriber</strong></p>
<p>The channel subscriber component represents the set of subscribable messages for a given stream.
It is implemented as a service, and should have one of your application services as a dependency.</p>
<p><strong>Message Subscriber</strong></p>
<p>The message subscriber component represents one of the publishable messages for a given stream.
It is implemented as a service created after configuration but before start-up.<br />
Notice that it has a defined API interface for mocking, and should be mocked by dependent services
during testing.</p>
<p><strong>Input Port</strong></p>
<p>The message port contains a mapping of fields to be set from the incoming message.
Each field will be mapped from a header or body field based on the struct tags.</p>
<p><strong>Payload DTO</strong></p>
<p>The payload DTO will contain the parsed message that is subscribed.
Before dispatch to your subscriber, the message will be validated using
the JSON-schema annotations and any <code>Validatable</code> interface implementation
on your DTO.</p>
<h2 id="generation-1"><a class="header" href="#generation-1">Generation</a></h2>
<p>It is strongly advised to auto-generate these components and customize them afterwards.
See <a href="ops/streamops/../../skel/asyncapi/channels.html">Channels</a> and <a href="ops/streamops/../../skel/asyncapi/spec.html">AsyncApi</a>
for details about generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncapi-schema"><a class="header" href="#asyncapi-schema">AsyncApi Schema</a></h1>
<p><a href="https://asyncapi.com">AsyncApi</a> Schema contains support infrastructure for
generating and consuming AsyncApi specifications directly from go code.</p>
<p>Microservice developers will typically interact with a small subset of AsyncApi 
models.</p>
<h2 id="documentation-generators"><a class="header" href="#documentation-generators">Documentation Generators</a></h2>
<p>Documentation Generators convert an active object from the <code>streamops</code> package
to a documentation element from this package.</p>
<ul>
<li><code>ChannelDocumentor</code>
<ul>
<li>Generates <code>ChannelItem</code> documentation from a <code>streamops.Channel</code></li>
</ul>
</li>
<li><code>ChannelPublisherDocumentor</code>
<ul>
<li>Generates <code>Operation</code> documentation from a <code>streamops.ChannelPublisher</code></li>
</ul>
</li>
<li><code>ChannelSubscriberDocumentor</code>
<ul>
<li>Generates <code>Operation</code> documentation from a <code>streamops.ChannelSubscriber</code> </li>
</ul>
</li>
<li><code>MessagePublisherDocumentor</code>
<ul>
<li>Generates <code>Message</code> documentation from a <code>streamops.MessagePublisher</code></li>
</ul>
</li>
</ul>
<p>Documentation Generators have the following user-modifiable properties:</p>
<ul>
<li><code>Skip</code>:
Set to true if you which to skip generating documentation for this node.</li>
<li><code>ChannelItem</code>/<code>Operation</code>/<code>Message</code>:
Specify a documentation element instance to use as the basis for generating
documentation for this node.  This is typically where you provide explanatory
fields such as title, description, etc.</li>
<li><code>Mutator</code>:
Specify a function to enable customization of the generated documentation
after the Documentor has processed this node.</li>
</ul>
<h2 id="documentation-elements"><a class="header" href="#documentation-elements">Documentation Elements</a></h2>
<p>Documentation Elements are generated by documentors and are inserted into the
AsyncApi specification document being generated.</p>
<ul>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#channelItemObject"><code>Channel</code></a>
<ul>
<li>Documents sequence of sent and received messages from a single location.</li>
</ul>
</li>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#messageObject"><code>Message</code></a>
<ul>
<li>Documents a single unit of communication sent to or received from a channel.</li>
</ul>
</li>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#operationObject"><code>Operation</code></a>
<ul>
<li>Documents a single channel operation (publish or subscriber) for a single channel.</li>
</ul>
</li>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#schemaObject"><code>Schema</code></a>
<ul>
<li>Documents the format of a message payload or headers.</li>
<li>In go-msx, this schema must be in <a href="https://json-schema.org/draft/2020-12/json-schema-validation.html">JSON Schema</a> format.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-lru-cache"><a class="header" href="#msx-lru-cache">MSX LRU Cache</a></h1>
<p>An LRU cache implementation which expires key/value pairs based on a TTL duration.
Inspired by <a href="https://github.com/karlseguin/rcache">rcache</a>.</p>
<ul>
<li>Entries are added with a key, a value and an individual TTL - time to live.</li>
<li>New uses should call NewCache2</li>
<li>The cache will expire entries after the TTL has passed.</li>
<li>The cache checks every <code>ExpireFrequency</code> for expired entries and expires them in batches of at most <code>ExpireLimit</code> at once.</li>
<li>The cache has no size limit. It will grow until the process runs out of memory, unless entries are expired.</li>
<li>The cache is safe for concurrent access.</li>
<li>The setting <code>DeAgeOnAccess</code> being true will cause the cache to reset the TTL of an entry when it is accessed or updated, in true LRU fashion.</li>
<li>When this setting is <code>false</code> (default for backwards compatibility) it behaves like a simple TTL cache. New uses should probably set this to <code>true</code>.</li>
<li>When the setting <code>metrics</code> is <code>true</code> (default <code>false</code>), the cache will emit metrics.</li>
<li>The timeSource setting is used to provide a clock for testing purposes.</li>
</ul>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<h3 id="instantiation-2"><a class="header" href="#instantiation-2">Instantiation</a></h3>
<p>To create a new cache with 120 second retention, which expires up to 100 keys every 15 seconds with de-aging switched on, metrics on, with prefix &quot;cat&quot;, and a normal time source:</p>
<pre><code class="language-go">myCache := lru.NewCache2(120 * time.Second, 100, 15 * time.Second, true,
	clock.New(), true, &quot;cat_&quot;)
</code></pre>
<p>lru provides an interface type Cache and a concrete type HeapMapCache; NewCache2 returns an instance of HeapMapCache which implements the former.</p>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>To store a key/value pair:</p>
<pre><code class="language-go">myCache.Set(&quot;somekey&quot;, &quot;myvalue&quot;)
</code></pre>
<h3 id="retrieval"><a class="header" href="#retrieval">Retrieval</a></h3>
<p>To retrieve a key/value pair:</p>
<pre><code class="language-go">value, exists := myCache.get(&quot;somekey&quot;)
if !exists { 
  // fill cache for &quot;somekey&quot;
}
</code></pre>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>When initialized with <code>metrics</code> set true, the cache will emit metric events to the stats package thus:</p>
<ul>
<li><code>entries</code>: the number of entries in the cache</li>
<li><code>hits</code>: the number of cache hits</li>
<li><code>misses</code>: the number of cache misses</li>
<li><code>sets</code>: the number of times set or setWithTTL were called</li>
<li><code>evictions</code>: the number of times an entry was evicted</li>
<li><code>gcRuns</code>: the number of times the garbage collector was run</li>
<li><code>gcSizes</code>: a histogram of the number of entries evicted in each garbage collection run</li>
<li><code>deAgedAt</code>: a histogram of the remaining time to live of entries when they are deaged</li>
</ul>
<p>The <code>metricsPrefix</code> setting is used to prefix the metrics names in the output system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-certificate"><a class="header" href="#msx-certificate">MSX Certificate</a></h1>
<p>The certificate module provides access to static and dynamic TLS/x509
certificate sources, including the following providers:</p>
<ul>
<li>File - load certs and keys from the filesystem</li>
<li>Vault - generate and renew certs and keys from Vault</li>
<li>Cache - save upstream certs and keys to disk</li>
</ul>
<p>The certificate module also provides a common configuration parser for
TLS configuration.</p>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<p>A source identifies the provider and provider parameters required to obtain identity and authority certificates.</p>
<p>Each source is defined in the configuration using a unique name (lowercase alphanumeric only).
Source properties are configured under <code>certificate.source.&lt;sourcename&gt;</code>, for example:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
      provider: ...
      property1: ...
      property2: ...
      property3: ...
</code></pre>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>Each source specifies a provider and its parameters.
Individual providers are detailed in the following sections.</p>
<h3 id="file"><a class="header" href="#file">File</a></h3>
<p>To specify the local filesystem as the source for certificates, use the File provider:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
    provider: file
    ca-cert-file: /etc/pki/tls/certs/ca-identity.crt
    cert-file: /etc/pki/tls/certs/spokeservice.pem
    key-file: /etc/pki/tls/private/spokeservice-key.pem
</code></pre>
<p>When a subsystem requests certificates from the <code>identity</code> source, it will:</p>
<ul>
<li>Load certificates from the filesystem for each TLS connection</li>
</ul>
<p>While <em>active</em> renewal is not supported, the file provider does read in changes
to the file for each connection.  The cert/key files may be rotated as convenient.</p>
<h4 id="configuration-properties"><a class="header" href="#configuration-properties">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ca-cert-file</code></td><td>-</td><td>Required</td><td>CA Certificate File, PEM format</td></tr>
<tr><td><code>cert-file</code></td><td>-</td><td>Required</td><td>Identity Certificate File, PEM format</td></tr>
<tr><td><code>key-file</code></td><td>-</td><td>Required</td><td>Identity Private Key File, PEM format</td></tr>
</tbody></table>
</div>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>To specify Vault as the source for certificates, use the Vault provider:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
    provider: vault
    path: pki/vms
    role: &quot;${spring.application.name}&quot;
    cn: &quot;${spring.application.name}&quot;
    alt-names:
      - &quot;${network.hostname}&quot;
      - &quot;${spring.application.name}.svc.kubernetes.cluster.local&quot;
      - &quot;${spring.application.name}.service.consul&quot;
    ip-sans:
      - &quot;${network.outbound.address}&quot;
</code></pre>
<p>When a subsystem requests certificates from the <code>identity</code> source, it will:</p>
<ul>
<li>Generate an identity certificate and private key</li>
<li>Renew the identity certificate half-way through its lifetime.</li>
</ul>
<h4 id="configuration-properties-1"><a class="header" href="#configuration-properties-1">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>-</td><td>Required</td><td>Vault PKI mount point</td></tr>
<tr><td><code>role</code></td><td>-</td><td>Required</td><td>Vault PKI issuer role name</td></tr>
<tr><td><code>cn</code></td><td>-</td><td>Required</td><td>Desired identity certificate CN</td></tr>
<tr><td><code>alt-names</code></td><td>-</td><td>Optional</td><td>Desired identity certificate subject alternative names</td></tr>
<tr><td><code>ip-sans</code></td><td>-</td><td>Optional</td><td>Desired identity certificate IP subject alternative names</td></tr>
</tbody></table>
</div>
<p>Note: <code>alt-names</code> and <code>ip-sans</code> will be stripped of empty entries so may include
undefined variables with empty defaults:</p>
<pre><code>- ${some.undefined.variable:}
</code></pre>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<p>To configure a cache for a remote certificate source, use the Cache provider:</p>
<pre><code class="language-yaml">certificate.source:

  identity:
    provider: vault
    path: pki/vms
    role: &quot;${spring.application.name}&quot;
    cn: &quot;${spring.application.name}&quot;
    alt-names:
      - &quot;${remote.service.hostname}&quot;
    ip-sans:
      - &quot;${kubernetes.pod.ip}&quot;
      - &quot;${remote.service.ip}&quot;
      
  identitycache:
    provider: cache
    upstream-source: identity
    key-file: &quot;/certs/${spring.application.name}-key.pem&quot;
    cert-file: &quot;/certs/${spring.application.name}.pem&quot;
    ca-cert-file: &quot;/etc/ssl/certs/ca-identity.crt&quot;
</code></pre>
<p>When a subsystem requests certificates from the <code>identitycache</code> source, it will:</p>
<ul>
<li>Generate and store an identity certificate and private key under <code>/certs</code></li>
<li>Retrieve and store the authority certificate under <code>/etc/ssl/certs</code>.</li>
<li>Renew the identity certificate half-way through its lifetime.</li>
</ul>
<h4 id="configuration-properties-2"><a class="header" href="#configuration-properties-2">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ca-cert-file</code></td><td>-</td><td>Required</td><td>CA Certificate File, PEM format</td></tr>
<tr><td><code>cert-file</code></td><td>-</td><td>Required</td><td>Identity Certificate File, PEM format</td></tr>
<tr><td><code>key-file</code></td><td>-</td><td>Required</td><td>Identity Private Key File, PEM format</td></tr>
</tbody></table>
</div>
<h2 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h2>
<p>TLS connection configuration is used in many places in go-msx, including:</p>
<ul>
<li>Kafka client</li>
<li>Web server</li>
</ul>
<p>For ease of use, these configurations have been unified into a single format.</p>
<h4 id="configuration-properties-3"><a class="header" href="#configuration-properties-3">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td><code>false</code></td><td>Optional</td><td>TLS should be enabled for this client/server</td></tr>
<tr><td><code>insecure-skip-verify</code></td><td><code>false</code></td><td>Optional</td><td>Verify the server's certificate chain and host name</td></tr>
<tr><td><code>min-version</code></td><td><code>tls12</code></td><td>Optional</td><td>Minimum TLS version to support.  One of: tls10, tls11, tls12, tls13</td></tr>
<tr><td><code>certificate-source</code></td><td>-</td><td>Optional</td><td>Server or Client certificate source.  Required for server.</td></tr>
<tr><td><code>cipher-suites</code></td><td><sup>1</sup></td><td>Optional</td><td>Cipher suites to enable.</td></tr>
<tr><td><code>server-name</code></td><td>-</td><td>Optional</td><td>Server name to check in certificate when connecting from client.</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Current default cipher suites are:</p>
<ul>
<li>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</li>
<li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li>
<li>TLS_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-resource-module"><a class="header" href="#msx-resource-module">MSX Resource Module</a></h1>
<p>MSX Resource manages locating and accessing files from the source, staging, and runtime filesystems in a consistent fashion.</p>
<h2 id="filesystem"><a class="header" href="#filesystem">Filesystem</a></h2>
<p>To correctly use resources, it is first important to understand the resource filesystem, and how it is used to locate files during development and inside containers.</p>
<p>The resource filesystem contains one or more of the following layers, if found:</p>
<ul>
<li><strong>production</strong> - rooted in the Docker image at <code>/var/lib/${app.name}</code></li>
<li><strong>staging</strong> - rooted at <code>dist/root/var/lib/${app.name}</code> underneath the <strong>source</strong> root</li>
<li><strong>source</strong> - rooted at the folder containing the repository's <code>go.mod</code></li>
</ul>
<p>The resource filesystem will attempt to locate each of these folders and if found, will search it for your resource references.</p>
<h2 id="resource-references"><a class="header" href="#resource-references">Resource References</a></h2>
<p>The primary data type of the MSX resource module is the resource reference.  It represents the resource file subpath.  All resource paths use the forward-slash (<code>/</code>) as the path component separator. </p>
<p>Two types of paths can be used:</p>
<ul>
<li><strong>relative</strong> - No leading forward-slash (<code>data/my-resource.json</code>): File path is relative to the code file consuming the reference.</li>
<li><strong>absolute</strong> - Leading forward-slash (<code>/internal/migrate/resource.json</code>): File path is relative to the resource filesystem root.</li>
</ul>
<h3 id="obtaining-a-single-resource-reference"><a class="header" href="#obtaining-a-single-resource-reference">Obtaining a Single Resource Reference</a></h3>
<p>To work with a resource you must first create a reference to it using the <code>resource.Reference</code> function:</p>
<pre><code class="language-go">func processMyResource(ctx context.Context) error {
  myResourceRef := resource.Reference(&quot;data/my-resource.json&quot;)
}
</code></pre>
<p>This returns a <code>resource.Ref</code> object pointing to the specified path.</p>
<h3 id="obtaining-multiple-resource-references"><a class="header" href="#obtaining-multiple-resource-references">Obtaining Multiple Resource References</a></h3>
<p>To retrieve multiple resource references using a glob pattern you can call the <code>resource.References</code> function:</p>
<pre><code>func processMyResources(ctx context.Context) error {
  myResourceRefs := resource.References(&quot;data/*.json&quot;)
}
</code></pre>
<p>This returns a <code>[]resource.Ref</code> slice with an entry for each matching resource.</p>
<h2 id="consuming-resources"><a class="header" href="#consuming-resources">Consuming Resources</a></h2>
<p>Once you have obtained one or more resource references, you can access their contents using one of its methods.</p>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>To read in the contents of the resource as JSON and unmarshal it to an object, use the <code>Unmarshal()</code> method:</p>
<pre><code class="language-go">var myResourceContents MyResourceStruct
err := resource.Reference(&quot;data/my-resource.json&quot;).Unmarshal(&amp;myResourceContents)
</code></pre>
<h3 id="bytes"><a class="header" href="#bytes">Bytes</a></h3>
<p>To read in the contents of the resource as a  <code>[]byte</code>, use the <code>ReadAll()</code> method:</p>
<pre><code class="language-go">data, err := resource.Reference(&quot;data/my-resource.json&quot;).ReadAll()
</code></pre>
<h3 id="httpfile"><a class="header" href="#httpfile">http.File</a></h3>
<p>To open the file and return an <code>http.File</code>, use the <code>Open()</code> method:</p>
<pre><code class="language-go">file, err := resource.Reference(&quot;data/my-resource.json&quot;).Open()
</code></pre>
<p>Note that <code>http.File</code> also meets the requirements of the <code>io.ReadCloser</code> interface, and can therefore be used with <code>io</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retry"><a class="header" href="#retry">Retry</a></h1>
<p>Retry enables attempting an operation multiple times, stopping
on success (no error returned) or permanent operation failure.</p>
<h2 id="retrying"><a class="header" href="#retrying">Retrying</a></h2>
<p>To retry an action, create a new instance of <code>Retry</code> via <code>NewRetry</code> and
call its <code>Retry</code> method:</p>
<pre><code class="language-go">
tooEarly := time.Parse(&quot;2020-01-01T00:00:00Z&quot;)
tooLate := time.Parse(&quot;2020-12-31T23:59:59.999999999Z&quot;)

// Retry once an hour
r := NewRetry(ctx, RetryConfig{Attempts:10, Delay: 60 * 60 * 1000})

err := r.Retry(func() error {
  now := time.Now()
  if now.Before(tooEarly) {
    return retry.TransientError{
      Cause: errors.New(&quot;Will succeed in the future&quot;)
    } 		
  } else if now.After(tooLate) {
    return retry.PermanentError{
      Cause: errors.New(&quot;Will never succeed again&quot;)			
    }
  }
  return nil
})
</code></pre>
<p>The above retries its action once per hour, with up to 10 attempts.
If the time is before <code>tooEarly</code>, it will continue retrying, since it
returns a <code>TransientError</code>.  If the time is after <code>tooLate</code>, it will
stop retrying, since it returns <code>PermanentError</code>.  If the time is after <code>tooEarly</code>
but before <code>tooLate</code>, it will succeed and cease further attempts.</p>
<p>Retry distinguishes between Transient and Permanent errors by inspecting
the returned <code>error</code> instance.  If it implements the failure interface,
it can be queried for transience/permanence:</p>
<pre><code class="language-go">type failure interface {
	IsPermanent() bool
}
</code></pre>
<p>Permanent errors should return <code>true</code> from <code>IsPermanent()</code>, transient
errors should return <code>false</code>.  As above, this can be handled by wrapping
the error in either <code>PermanentError</code> or <code>TransientError</code>.</p>
<h2 id="configuration-loading-1"><a class="header" href="#configuration-loading-1">Configuration Loading</a></h2>
<p><code>RetryConfig</code> is designed to be loaded from configuration, making it possible
to configure from static, environmental, or remote configuration
sources in a consistent fashion.</p>
<pre><code class="language-go">const configRootMerakiClientRetry = &quot;meraki.client.retry&quot;
var retryConfig retry.Config
if err := config.FromContext(ctx).Populate(&amp;retryConfig, configRootMerakiClientRetry); err != nil {
	return err
}
</code></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<ul>
<li>
<p>Retries without delays</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 2,
    Delay:    0,
    BackOff:  0.0,
    Linear:   true,
})
</code></pre>
</li>
<li>
<p>Retries with fixed delays (1 second)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 2,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
})
</code></pre>
</li>
<li>
<p>Retries with linear delays (1, 2, 3, 4)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
})
</code></pre>
</li>
<li>
<p>Retries with exponential delays (1, 2, 4, 8)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay: 1000,
    BackOff: 2.0,
    Linear: false,
})
</code></pre>
</li>
<li>
<p>Retries with linear delay and Jitter (low random) (1, 2.452, 3.571, 4.357) <br /></p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
    Jitter:   1000,
})
</code></pre>
</li>
<li>
<p>Retries with linear delay and Jitter (extreme random) (1, 7.8, 20.3, 8.45) <br />
With higher Jitter value you could expect greater randomness.</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
    Jitter:   20000,
})
</code></pre>
</li>
<li>
<p>Retries with exponential delay and Jitter (1, 2, 4, 8) (note: jitter is negligible so this is just like exponential backoff with no jitter)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay: 1000,
    BackOff: 2.0,
    Linear: false,
    Jitter: 1,
})
</code></pre>
</li>
<li>
<p>Using retry with decorator</p>
<pre><code class="language-go">    types.
        NewOperation(func(ctx context.Context) error {
            return errors.New(&quot;a transient error&quot;)
        }).
        WithDecorator(Decorator(RetryConfig{
            Attempts: 1,
            Delay:    10,
            BackOff:  2.0,
            Linear:   false,
            Jitter:   1,
        })).
        Run(ctx)
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sanitize"><a class="header" href="#sanitize">Sanitize</a></h1>
<p>MSX Sanitize allows request data to be pre-processed (before validation) to ensure potentially dangerous content is
removed. For example XSS and arbitrary HTML can be removed from plain-text strings.  MSX Sanitize also auto-sanitizes
log messages.</p>
<h2 id="sanitizing-input"><a class="header" href="#sanitizing-input">Sanitizing Input</a></h2>
<p>To explicitly sanitize a tree of data, including maps, slices, structs in-place:</p>
<pre><code class="language-go">if err := sanitize.Input(&amp;mydata, sanitize.NewOptions(&quot;xss&quot;)); err != nil {
	return err
}
</code></pre>
<p>After returning, mydata will be sanitized based on the supplied Options.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>Options are available for each of the sanitizers from</p>
<pre><code>github.com/kennygrant/sanitize
</code></pre>
<p>including:</p>
<ul>
<li>Accents (<code>accents</code>) </li>
<li>BaseName (<code>basename</code>)</li>
<li>Xss (<code>xss</code>) </li>
<li>Name (<code>name</code>)</li>
<li>Path (<code>path</code>)</li>
</ul>
<p>Custom sanitizers provided by MSX Sanitize include:</p>
<ul>
<li>Secret (<code>secret</code>)</li>
</ul>
<h3 id="struct-tags-2"><a class="header" href="#struct-tags-2">Struct Tags</a></h3>
<p>To specify these options on a struct field, use the <code>san:&quot;...&quot;</code> tag, for example:</p>
<pre><code class="language-go">type MyRequest struct {
	Name 		string `json:&quot;name&quot; san:&quot;xss&quot;`
	Description string `json:&quot;description&quot; san:&quot;xss&quot;`
	Ignored 	string `json:&quot;ignored&quot; san:&quot;-&quot;`
}
</code></pre>
<p>In this struct, <code>Name</code> and <code>Description</code> fields indicate they must be sanitized for XSS/HTML content (<code>xss</code>),
and <code>Ignored</code> should not be sanitized at all (<code>-</code>).</p>
<p>NOTE: If a struct field does not have the <code>san</code> tag, it will inherit from its ancestors, up to the options passed
into the <code>sanitize.Input</code> call.</p>
<h2 id="sanitizing-logs"><a class="header" href="#sanitizing-logs">Sanitizing Logs</a></h2>
<p>Logs are auto-sanitized using some base rules.  These can be augmented by the microservice using the 
<code>sanitize.secrets</code> configuration:</p>
<pre><code class="language-yaml">sanitize.secrets:
  keys:
    - status
  custom:
    enabled: true
    patterns:
        - from: &quot;\\[userviceconfiguration/\\w+\\]&quot;
          to: &quot;[userviceconfiguration/...]&quot;
        - from: &quot;\\[secret/\\w+\\]&quot;
          to: &quot;[secret/...]&quot;
</code></pre>
<p>Within <code>sanitize.secrets</code> you can configure the following options:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>true</td><td>Optional</td><td>Enable secret replacement</td></tr>
<tr><td><code>keys</code></td><td>-</td><td>Optional</td><td>A set of XML/JSON/ToString attributes and objects to flag as sensitive</td></tr>
<tr><td><code>custom.*</code></td><td>-</td><td>Optional</td><td>Custom go regex replacement.  Does not use <code>keys</code>.</td></tr>
<tr><td><code>json.*</code></td><td>-</td><td>Optional</td><td>JSON replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
<tr><td><code>xml.*</code></td><td>-</td><td>Optional</td><td>XML replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
<tr><td><code>to-string.*</code></td><td>-</td><td>Optional</td><td>Stringer replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
</tbody></table>
</div>
<p>For <code>custom</code>, specify a list of regexes and replacements in <code>custom.patterns</code>, as above.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>custom.patterns[*].from</code></td><td>-</td><td>Required</td><td>Regex to match</td></tr>
<tr><td><code>custom.patterns[*].to</code></td><td>-</td><td>Required</td><td>Replacement (including variables)</td></tr>
</tbody></table>
</div>
<p>For <code>json</code>, <code>xml</code>, <code>tostring</code>, specify a list of regexes to match, including the named capture groups
<code>prefix</code> and <code>postfix</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.enabled</code></td><td>true</td><td>Optional</td><td>Enable this set of patterns (<code>json</code>, <code>xml</code>, <code>to-string</code>)</td></tr>
<tr><td><code>.patterns[*].from</code></td><td>-</td><td>Required</td><td>Regex to match</td></tr>
<tr><td><code>.patterns[*].to</code></td><td><code>${prefix}*****${postfix}</code></td><td>Optional</td><td>Replacement (including regex variables)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="msx-scheduled-module"><a class="header" href="#msx-scheduled-module">MSX Scheduled Module</a></h1>
<p>MSX Scheduled manages the periodic execution of tasks within microservices.</p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>The work to be performed on a periodic basis must be surrounded in an Action (a function signature matching<code>types.ActionFunc</code>):</p>
<pre><code class="language-go">func doWork(ctx context.Context) error {
  // TODO: perform the desired work.
} 
</code></pre>
<p>Actions can be anonymous functions, struct methods (as above), or static methods, and can also be derived from Operations (<code>types.Operation</code>).</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<p>Scheduling a task requires two steps: Configuration and Registration.</p>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<p>To configure the periodic execution, your task will need a simple name to identify its configuration.  For example, the <code>do-work</code> task can be configured as:</p>
<pre><code class="language-yaml">scheduled.tasks:
    do-work:
        fixed-interval: 10m
        # fixed-delay: 5m
        # initial-delay: 15m
        # cron-expression: &quot;0 0 0 * *&quot;
</code></pre>
<p>This example configuration will execute the <code>do-work</code> task (once registered) every 10 minutes.</p>
<p>To ensure a fixed period <em>between</em> executions, use the <code>fixed-delay</code> configuration instead.</p>
<p>To specify an initial delay before first execution that is different from <code>fixed-delay</code> or <code>fixed-interval</code>, specify the <code>initial-delay</code>.</p>
<p>To use a CRON expression to specify the execution schedule, use the <code>cron-expression</code> configuration.  For an overview of CRON expressions, see <a href="https://en.wikipedia.org/wiki/Cron">here</a>.</p>
<h3 id="registration"><a class="header" href="#registration">Registration</a></h3>
<p>To register your task at runtime, call the <code>scheduled.ScheduleTask</code> function during the application Start:</p>
<pre><code class="language-go">const taskNameDoWork = &quot;do-work&quot;

func init() {
  app.OnRootEvent(app.EventStart, app.PhaseAfter, func(ctx context.Context) error {
        return scheduled.ScheduleTask(ctx, taskNameDoWork, doWork)
  })
}
</code></pre>
<p>This will load the configuration using the supplied task name, and schedule the task according to the configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-transit-module"><a class="header" href="#msx-transit-module">MSX Transit Module</a></h1>
<p>MSX transit is an implementation of transit encryption.  It allows swappable encryption implementations via the <code>Provider</code> interface.</p>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<p>The primary mode of consumption for MSX Transit is within business Models.  To add transit encryption support to your model, add an anonymous <code>transit.WithSecureData</code> member to your model structure:</p>
<pre><code class="language-go">type Organization struct {
	transit.WithSecureData
	OrganizationId string     `db:&quot;organization_id&quot;`
	TenantId       gocql.UUID `db:&quot;tenant_id&quot;`
}
</code></pre>
<p>This embedded struct will store its data in a field named <code>secure_data</code>, so a migration will need to add such a field if the table already exists:</p>
<pre><code class="language-sql">ALTER TABLE organization ADD COLUMN secure_data TEXT;
</code></pre>
<p>To store and retrieve individual encrypted fields from your model, add accessors:</p>
<pre><code class="language-go">const secureDataMerakiApiKey = &quot;merakiApiKey&quot;

func (o *Organization) MerakiApiKey(ctx context.Context) (string, error) {
	return o.SecureValue(ctx, organizationSecureFieldMerakiApiKey)
}

func (o *Organization) SetMerakiApiKey(ctx context.Context, value *string) error {
	return o.SetSecureValue(ctx, o.TenantId.Bytes(), secureDataMerakiApiKey, value)
}
</code></pre>
<p>You can then use these accessors in your converter and services to retrieve and store the values from your model.</p>
<h3 id="per-application-encryption"><a class="header" href="#per-application-encryption">Per-Application Encryption</a></h3>
<p>Sometimes you will want values to be encrypted, but non on a per-tenant basis.  In this case, define your key id within your domain package, and use it in place of the TenantId in your property setters:</p>
<pre><code class="language-go">var appKeyId := types.MustParseUUID(&quot;3e246fc7-12d8-4626-a739-1fd22bbf47f0&quot;)

func (o *Organization) SetMerakiApiKey(ctx context.Context, value *string) error {
	return o.SetSecureValue(ctx, appKeyId.Bytes(), secureDataMerakiApiKey, value)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Skel is a tool for generating MSX service skeletons and components. It is a part of
the go-msx library and tools, and the skeleton projects it generates are compatible
with the go-msx framework.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>You may install Skel either by cloning the git repo and using golang's install command, or by copying the 'skel' binary
from the repo's 'bin' directory; the latter is recommended since you will need to update it from time to time.</p>
<p>In either case, you will need to ensure that Git is set up and can communicate with the cto-github.cisco.com server. See
the <a href="skel/docs/../../index.html#requirements">go-msx README</a> for details.</p>
<h2 id="install-from-artifactory"><a class="header" href="#install-from-artifactory">Install from Artifactory</a></h2>
<ol>
<li>
<p>Download the skel tarball:</p>
<p><strong>MacOS</strong>:</p>
<pre><code class="language-bash">curl -L -o - https://engci-maven-master.cisco.com/artifactory/symphony-group/com/cisco/vms/go-msx-skel/latest/go-msx-skel-darwin-latest.tar.gz | tar -xzf -
</code></pre>
<p><strong>Linux</strong>:</p>
<pre><code class="language-bash">curl -L -o - https://engci-maven-master.cisco.com/artifactory/symphony-group/com/cisco/vms/go-msx-skel/latest/go-msx-skel-linux-latest.tar.gz | tar -xzf -
</code></pre>
</li>
<li>
<p>Move the skel binary to a location in your path:</p>
<pre><code class="language-bash">mv skel ~/go/bin
</code></pre>
</li>
</ol>
<h2 id="install-via-go"><a class="header" href="#install-via-go">Install via Go</a></h2>
<p>Prerequisite: <strong>Go 1.18+</strong></p>
<ol>
<li>
<p>Ensure your GOBIN environment variable is correctly set and referenced in your PATH. For example:</p>
<pre><code class="language-bash">export GOPATH=~/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
<p>Recall that GOBIN defaults to <code>$GOPATH/bin</code>, or <code>$HOME/go/bin</code> if the <code>GOPATH</code>
environment variable is not set.</p>
</li>
<li>
<p>Be sure to set your Go proxy settings correctly. For example:</p>
<pre><code class="language-bash">go env -w GOPRIVATE=cto-github.cisco.com/NFV-BU
</code></pre>
</li>
<li>
<p>Check-out go-msx into your local workspace:</p>
<pre><code class="language-bash">mkdir -p $HOME/msx &amp;&amp; cd $HOME/msx
git clone git@cto-github.cisco.com:NFV-BU/go-msx.git
cd go-msx
go mod download
</code></pre>
</li>
<li>
<p>Install <code>skel</code>:</p>
<pre><code class="language-bash">make install-skel
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-7"><a class="header" href="#usage-7">Usage</a></h1>
<p>Skel may be run using either command-line sub-commands or by using its minimal, but hopefully helpful, interactive mode.</p>
<ul>
<li>
<p>To start the interactive project generator, run the skel command with no arguments:</p>
<pre><code class="language-bash">skel
</code></pre>
</li>
<li>
<p>To list the targets and options for the skel command, add the <code>-h</code> flag:</p>
<pre><code class="language-bash">skel -h
</code></pre>
</li>
<li>
<p>To get help for a particular target:</p>
<pre><code class="language-bash">skel &lt;target&gt; -h
</code></pre>
</li>
</ul>
<p>In addition to the numerous generation targets, there are the following utility targets:</p>
<ul>
<li><code>help</code>: display the help text</li>
<li><code>version</code>: display the current, and most recent <code>skel</code> build versions</li>
<li><code>completion</code>: generate the BASH completion script for <code>skel</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-microservice"><a class="header" href="#generic-microservice">Generic Microservice</a></h1>
<ul>
<li><em>Contains:</em> {wazinnit}</li>
<li><em>Root dir:</em> ./{serviceName}/</li>
<li><em>Command:</em> <code>generate-app</code></li>
<li><em>Menu:</em> Generate Archetype | Generic Microservice</li>
</ul>
<p>A generic MSX app skeleton that contains various bony bits ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probes-beats"><a class="header" href="#probes-beats">Probes (Beats)</a></h1>
<p>Probes enable the collection of operational data from remote systems
on a per-device basis.</p>
<ul>
<li>
<p>To generate an operational data collector:</p>
<pre><code class="language-bash">skel
</code></pre>
<pre><code>? Generate archetype: Beat
? Project Parent Directory: /Users/mcrawfo2/msx/demos
? Version: 5.0.0
? Protocol: arp
? Build notifications slack channel: go-msx-build
? Primary branch name: main
</code></pre>
</li>
</ul>
<p>For more details about creating and implementing probes, please see the 
<a href="https://cto-github.cisco.com/NFV-BU/go-msx-beats/blob/master/docs/writing-a-new-beat.md">Writing a New Beat</a> 
tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<ul>
<li>
<p>To interactively generate a channel publisher or subscriber, for one or
more messages:</p>
<pre><code class="language-bash">skel generate-channel
</code></pre>
</li>
<li>
<p>To generate a channel supporting a single message publisher:</p>
<pre><code class="language-bash">skel generate-channel-publisher &quot;COMPLIANCE_EVENT_TOPIC&quot;
</code></pre>
</li>
<li>
<p>To generate a channel supporting multiple message publishers,
or add another message publisher to an existing multi-message publisher
channel:</p>
<pre><code class="language-bash">skel generate-channel-publisher &quot;COMPLIANCE_EVENT_TOPIC&quot; --message &quot;DriftCheck&quot;
</code></pre>
</li>
<li>
<p>To generate a channel supporting a single message subscriber:</p>
<pre><code class="language-bash">skel generate-channel-subscriber &quot;COMPLIANCE_EVENT_TOPIC&quot;
</code></pre>
</li>
<li>
<p>To generate a channel supporting multiple message subscribers,
or add another message subscriber to an existing multi-message subscriber
channel:</p>
<pre><code class="language-bash">skel generate-channel-subscriber &quot;COMPLIANCE_EVENT_TOPIC&quot; --message &quot;DriftCheck&quot;
</code></pre>
</li>
</ul>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<p>From the above examples, the following files may be generated:</p>
<ul>
<li><code>pkg.go</code>
<ul>
<li>Package-wide logger</li>
<li>Context Key type definition</li>
<li>Channel for <code>COMPLIANCE_EVENT_TOPIC</code></li>
<li>Channel documentation (<code>asyncapi.Channel</code>)</li>
</ul>
</li>
<li><code>publisher_channel.go</code>
<ul>
<li>Channel publisher for the package channel</li>
<li>Channel publisher documentation (<code>asyncapi.Operation</code>)</li>
</ul>
</li>
<li><code>subscriber_channel.go</code>
<ul>
<li>Channel subscriber for the package channel</li>
<li>Channel subscriber documentation (<code>asyncapi.Operation</code>)</li>
</ul>
</li>
<li><code>publisher_*.go</code>
<ul>
<li>Message publisher for individual outgoing messages</li>
<li>Message publisher documentation (<code>asyncapi.Message</code>)</li>
</ul>
</li>
<li><code>subscriber_*.go</code>
<ul>
<li>Message subscriber for individual incoming messages</li>
<li>Message subscriber documentation (<code>asyncapi.Message</code>)</li>
</ul>
</li>
<li><code>api/*.go</code>
<ul>
<li>DTOs for published messages (eg <code>DriftCheckRequest</code>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncapi"><a class="header" href="#asyncapi">AsyncAPI</a></h1>
<ul>
<li>
<p>To interactively generate a channel publisher or subscriber, for one or
more channels from an existing AsyncApi specification via url or local path:</p>
<pre><code class="language-bash">skel generate-channel-asyncapi
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification via url:</p>
<pre><code class="language-bash">export ASYNCAPI_SPEC_URL=&quot;https://cto-github.cisco.com/raw/NFV-BU/merakigoservice/develop/api/asyncapi.yaml?token=...&quot;
skel generate-channel-asyncapi &quot;$ASYNCAPI_SPEC_URL&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification from a local
specification:</p>
<pre><code class="language-bash">skel generate-channel-asyncapi &quot;api/asyncapi.yaml&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification via url:</p>
<pre><code class="language-bash">export ASYNCAPI_SPEC_URL=&quot;https://cto-github.cisco.com/raw/NFV-BU/merakigoservice/develop/api/asyncapi.yaml?token=...&quot;
skel generate-channel-asyncapi &quot;$ASYNCAPI_SPEC_URL&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification from a local
specification:</p>
<pre><code class="language-bash">skel generate-channel-asyncapi &quot;api/asyncapi.yaml&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skel-skaffold-integration"><a class="header" href="#skel-skaffold-integration">Skel Skaffold Integration</a></h1>
<h2 id="generate-project-skaffold-support"><a class="header" href="#generate-project-skaffold-support">Generate Project Skaffold Support</a></h2>
<p>A <code>skaffold.yaml</code> file will be created in the root of any app or service pack project you create using <code>skel</code>, no extra action is required.</p>
<p>In addition, <code>deployments/kubernetes/minivms/${app.name}-deployment.yaml</code> and <code>deployments/kubernetes/msxlite/${app.name}-deployment.yaml</code> will be created.</p>
<p>If your project has already been generated, you can use the <code>skel generate-kubernetes</code> command inside the project folder to add the skaffold support files.</p>
<h2 id="configure-kubernetes"><a class="header" href="#configure-kubernetes">Configure Kubernetes</a></h2>
<ol>
<li>Connect to your msx-lite instance (the kubernetes host, not the installer), and retrieve your kubernetes configuration:</li>
</ol>
<pre><code>kubectl config view --raw --minify
</code></pre>
<ol start="2">
<li>Apply this configuration as either the default kubernetes configuration, or as a custom configuration referred to by the <code>KUBECONFIG</code> environment variable:</li>
</ol>
<pre><code>mkdir -p $HOME/.kube
cat &gt; $HOME/.kube/config &lt;&lt;EOF
&lt;config contents from instance go here&gt;
EOF
</code></pre>
<ol start="3">
<li>Update the server URL in the kubeconfig file you just saved to refer to the lab IP address:</li>
</ol>
<pre><code>#    server: https://127.0.0.1:6443 
     server: https://10.81.85.174:6443
</code></pre>
<ol start="4">
<li>If using a non-default config file, ensure <code>KUBECONFIG</code> is set in your bash profile to point to the new file:</li>
</ol>
<pre><code>export KUBECONFIG=$HOME/.kube/rtp-4-msx-lite-35/config
</code></pre>
<h2 id="setup-skaffold-support-in-goland"><a class="header" href="#setup-skaffold-support-in-goland">Setup Skaffold Support in GoLand</a></h2>
<p>To set up <code>skaffold</code> in GoLand:</p>
<ol>
<li>
<p>Install Skaffold: Follow the instructions at https://skaffold.dev/docs/install/ to install Skaffold 2.x or higher on your system.</p>
</li>
<li>
<p>Install the Skaffold plugin for GoLand: In GoLand, go to <code>Goland | Settings | Plugins...</code>, search for &quot;Cloud Code&quot;, and click the Install button</p>
</li>
<li>
<p>You <em>may</em> need to restart GoLand</p>
</li>
</ol>
<h2 id="create-an-msx-lite-run-configuration"><a class="header" href="#create-an-msx-lite-run-configuration">Create an MSX-Lite Run Configuration</a></h2>
<ol>
<li>
<p>When you open your generated project in GoLand you should now see a popup saying &quot;Kubernetes with Cloud Code. Skaffold configuration detected&quot; since there will be a skaffold.yaml in the root</p>
</li>
<li>
<p>Via the <code>Add Configuration</code> link therein, or via the light blue <code>Add Configuration</code> button top right, or via <code>Run | Edit Configurations | +</code> add a run config</p>
</li>
<li>
<p>Select the config type: &quot;Cloud Code: Kubernetes&quot;</p>
</li>
<li>
<p>Give the configuration a name</p>
</li>
<li>
<p>On the run tab, <code>Environment Variables</code> specify:</p>
<p><code>SKAFFOLD_PROFILE=msxlite</code></p>
<p>this tells skaffold to use the msxlite deployment found in the msxlite subdir </p>
</li>
<li>
<p>Give the path to the <code>skaffold.yaml</code> file on the &quot;Build | Deploy&quot; tab (it should default correctly)</p>
</li>
<li>
<p>You probably want &quot;All Modules and Dependencies&quot; selected </p>
</li>
<li>
<p>Now you can run that config to deploy using skaffold </p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="makefile-usage"><a class="header" href="#makefile-usage">Makefile Usage</a></h1>
<p>go-msx uses GNU Make to present abstract build targets for developers and Continuous Integration
systems.  This allows for consistent builds across a variety of environments, and development
of Continuous Integration without a hosted job runner.</p>
<p><code>make</code> may be run directly to execute targets.</p>
<ul>
<li>
<p>To list the targets in the Makefile, execute the <code>help</code> target:</p>
<pre><code class="language-bash">make help
</code></pre>
<p>Sample output is shown below.</p>
</li>
<li>
<p>To pass flags to the <code>go</code> command when executing <code>build</code>:</p>
<pre><code class="language-bash">export BUILDER_FLAGS='-exec xprog'
make vet
</code></pre>
</li>
<li>
<p>To pass flags to the <code>build</code> command when executing <code>build</code>:</p>
<pre><code class="language-bash">export BUILD_FLAGS='--artifactory.password=&quot;cisco123&quot;'
make publish
</code></pre>
</li>
</ul>
<p>In addition to the numerous build targets (below), there are the following utility targets:</p>
<ul>
<li><code>help</code>: display the help text</li>
</ul>
<h2 id="targets"><a class="header" href="#targets">Targets</a></h2>
<pre><code>assemblies               Generate supplemental artifacts
clean                    Remove any temporary build outputs
debug                    Build a debug executable
deploy-github-repo       Configure a standard github repository
deploy-jenkins-job       Upload a standard Jenkins build job to MSX Jenkins
deployment               Generate the installer deployment variables
deps                     Install dependencies
dist                     Build all outputs required for a container image
docker                   Generate a docker image for this service
docker-debug             Generate a debugging docker image for this service
docker-publish           Publish a docker image for this service
generate                 Execute code generation
help                     Show this help
manifest                 Generate the installer manifest
openapi-compare          Compare the openapi contracts for the microservice
openapi-generate         Store the openapi contract for the microservice
package                  Generate an SLM package
package-deploy           Deploy this service using SLM to an MSX instance
package-publish          Publish this service as an SLM package to S3
precommit                Ensure the code is ready for committing to version control
publish                  Publish all artifacts required for the installer
tag                      Tag the repository with a new PATCH version number
test                     Execute unit tests
update-go-msx            Update the go-msx library dependency to the latest version
update-go-msx-build      Update the go-msx-build library dependency to the latest version
update-go-msx-populator  Update the go-msx-populator library dependency to the latest version
verify-contract          Ensure the openapi contract matches the generated code
vet                      Use go vet to validate sources
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-usage"><a class="header" href="#build-usage">Build Usage</a></h1>
<p><code>build</code> may be run directly using command-line targets.</p>
<ul>
<li>
<p>To list the targets and options for the build command, add the <code>-h</code> flag:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build.yml -h
</code></pre>
</li>
<li>
<p>To get help for a particular target:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build.yml &lt;target&gt; -h
</code></pre>
</li>
<li>
<p>To pass a custom build configuration, use the <code>--config</code> option:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build-custom.yml &lt;target&gt;
</code></pre>
</li>
</ul>
<p>In addition to the numerous build targets (below), there are the following utility targets:</p>
<ul>
<li><code>help</code>: display the help text</li>
<li><code>version</code>: display the current, and most recent <code>skel</code> build versions</li>
<li><code>completion</code>: generate the BASH completion script for <code>skel</code></li>
</ul>
<h2 id="targets-1"><a class="header" href="#targets-1">Targets</a></h2>
<pre><code>Available Commands:
build-assemblies              Builds Assemblies
build-debug-executable        Build the binary debug executable
build-executable              Build the binary executable
build-installer-manifest      Generate the installer manifests
build-package                 Build the service deployment package
build-tool                    Build the binary tool
compare-openapi-spec          Compares the current openapi spec with the stored version
completion                    Generate the autocompletion script for the specified shell
deploy-github-repo            Deploy Github repository
deploy-jenkins-job            Deploy Jenkins job
deploy-package                Deploy the service to an MSX instance
docker-build                  Build the target release docker image
docker-build-debug            Build the target debug docker image
docker-push                   Push the target docker image to the upstream repository
docker-save                   Save the target docker image to the specified file
download-generate-deps        Download generate dependencies
download-seccomp-dependencies Download seccomp dependencies
download-test-deps            Download test dependencies
execute-unit-tests            Execute unit tests
generate                      Generate code
generate-build-info           Create a build metadata file
generate-deployment-variables Stage variables file with build version
generate-openapi-spec         Stores the current openapi spec into a file
generate-seccomp-profile      Create a seccomp profile
git-tag                       Tag the current commit
go-fmt                        Format all go source files
go-vet                        Vet all go source files
help                          Help about any command
install-asyncapi-ui           Installs AsyncAPI/Studio package
install-dependency-configs    Download dependency config files to distribution config directory
install-entrypoint            Copy custom entrypoint to distribution root directory
install-executable-configs    Copy configured files to distribution config directory
install-extra-configs         Copy custom files to distribution config directory
install-resources             Installs Resources
install-swagger-ui            Installs Swagger-UI package
license                       License all go source files
publish-binaries              Publishes Binaries
publish-installer-manifest    Deploy the installer manifests
publish-package               Publish the service deployment package
publish-tool                  Publish the binary tool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-configuration"><a class="header" href="#build-configuration">Build Configuration</a></h1>
<p>go-msx Build uses YAML build configuration files to define the build to be executed.
A build configuration describes the build metadata for one of:</p>
<ul>
<li>Microservice</li>
<li>Command Line tool</li>
<li>Service Pack</li>
<li>Library</li>
</ul>
<p>A build configuration file can include these artifacts:</p>
<ul>
<li>Binary artifacts</li>
<li>Assemblies (tarballs)</li>
<li>Resources</li>
<li>Runtime Configuration Files</li>
<li>Docker Images</li>
</ul>
<h2 id="configuration-sources"><a class="header" href="#configuration-sources">Configuration Sources</a></h2>
<p>Like all go-msx applications, go-msx-build can retrieve configuration from a variety of sources:</p>
<ul>
<li>Environment</li>
<li>Command-Line Options</li>
<li>Build Configuration Files</li>
<li>Application Configuration Files</li>
<li>Defaults</li>
</ul>
<p>To specify the primary build configuration file, pass the <code>--config</code> option to build:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build.yml
</code></pre>
<p>This will normally be handled by the Makefile.</p>
<p>Configuration passed in by either Environment Variables or Command-Line Options will override
values also specified in Files or Defaults.</p>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>Some settings are intended to be injected from environment variables.  These include:</p>
<ul>
<li><code>docker.username</code> (<code>DOCKER_USERNAME</code>)</li>
<li><code>docker.password</code> (<code>DOCKER_PASSWORD</code>)</li>
<li><code>artifactory.username</code> (<code>ARTIFACTORY_USERNAME</code>)</li>
<li><code>artifactory.password</code> (<code>ARTIFACTORY_PASSWORD</code>)</li>
<li><code>build.number</code> (<code>BUILD_NUMBER</code>)</li>
<li><code>manifest.folder</code> (<code>MANIFEST_FOLDER</code>)</li>
<li><code>jenkins.username</code> (<code>JENKINS_USERNAME</code>)</li>
<li><code>jenkins.password</code> (<code>JENKINS_PASSWORD</code>)</li>
<li><code>github.token</code> (<code>GITHUB_TOKEN</code>)</li>
</ul>
<p>It is considered unsafe or inflexible to store them directly in the configuration file.
The default generated Jenkinsfile will automatically inject these environment
variables as required by the relevant steps.</p>
<h3 id="application-configuration"><a class="header" href="#application-configuration">Application Configuration</a></h3>
<p>Some settings below are intended to be read from the application configuration files.<br />
These include:</p>
<ul>
<li><code>info.app.*</code> - <code>bootstrap.yml</code></li>
<li><code>server.*</code> - <code>bootstrap.yml</code></li>
</ul>
<p>To ensure these are being read from the correct source, ensure the <code>executable.config-files</code> list
contains the base application configuration files (eg <code>bootstrap.yml</code>).</p>
<p>Example:</p>
<pre><code class="language-yaml">executable:
  configFiles:
    - bootstrap.yml
</code></pre>
<h2 id="configuration-sections"><a class="header" href="#configuration-sections">Configuration Sections</a></h2>
<h3 id="executable"><a class="header" href="#executable"><code>executable</code></a></h3>
<p>The <code>executable</code> configuration specifies the entrypoint and primary configuration file(s) of this build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>executable.cmd</code></td><td><code>app</code></td><td>Optional</td><td>The <code>cmd</code> sub-folder containing the application <code>main</code> module.</td></tr>
<tr><td><code>executable.config-files</code></td><td>-</td><td>Required</td><td>A list of configuration files within the main module to include in the build.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">executable:
  configFiles:
    - bootstrap.yml
    - dnaservice.production.yml
</code></pre>
<h3 id="msx"><a class="header" href="#msx"><code>msx</code></a></h3>
<p>The <code>msx</code> configuration specifies details of the MSX release to interface with.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>msx.release</code></td><td>-</td><td>Required</td><td>The MSX release of this microservice (output).</td></tr>
<tr><td><code>msx.deployment-group</code></td><td>-</td><td>Required</td><td>The deployment group of the build.</td></tr>
<tr><td><code>msx.platform.parent-artifacts</code></td><td>-</td><td>Required</td><td>Maven artifact roots to scan for default properties.</td></tr>
<tr><td><code>msx.platform.version</code></td><td>-</td><td>Required</td><td>The platform version to use for locating maven artifacts.  Accepts <code>EDGE</code> and <code>STABLE</code> builds.</td></tr>
<tr><td><code>msx.platform.include-groups</code></td><td>-</td><td>Required</td><td>Maven artifact groupIds to include in artifact scanning.</td></tr>
<tr><td><code>msx.platform.swagger-artifact</code></td><td><code>com.cisco.nfv:nfv-swagger</code></td><td>Optional</td><td>MSX artifact groupId and artifactId for nfv-swagger.</td></tr>
<tr><td><code>msx.platform.swagger-webjar</code></td><td><code>org.webjars:swagger-ui:3.23.11</code></td><td>Optional</td><td>Maven artifact triple for swagger web jar.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">msx:
  release: 3.10.0
  deploymentGroup: dna
  platform:
    parentArtifacts:
      - com.cisco.vms:vms-service-starter
      - com.cisco.vms:vms-service-starter-core
      - com.cisco.vms:vms-service-starter-kafka
      - com.cisco.nfv:nfv-integration-consul-leader
    version: 3.10.0-EDGE
    includeGroups: &quot;com.cisco.**&quot;
</code></pre>
<h3 id="docker"><a class="header" href="#docker"><code>docker</code></a></h3>
<p>The <code>docker</code> configuration controls interactions with the docker daemon, global repository,
images, and <code>Dockerfile</code> scripts.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>docker.dockerfile</code></td><td><code>docker/Dockerfile</code></td><td>Optional</td><td>The <code>Dockerfile</code> used for this build.</td></tr>
<tr><td><code>docker.baseimage</code></td><td><code>msx-base-buster:3.9.0-70</code></td><td>Optional</td><td>The base image within the repository.</td></tr>
<tr><td><code>docker.repository</code></td><td><code>dockerhub.cisco.com/vms-platform-dev-docker</code></td><td>Optional</td><td>The repository source and destination.</td></tr>
<tr><td><code>docker.username</code></td><td>-</td><td>Optional</td><td>User name to authenticate to repository.</td></tr>
<tr><td><code>docker.password</code></td><td>-</td><td>Optional</td><td>Password to authenticate to repository.</td></tr>
<tr><td><code>docker.buildkit</code></td><td>-</td><td>Optional</td><td><code>true</code> to use docker buildkit when building the docker image.</td></tr>
<tr><td><code>docker.base.dynamic.enabled</code></td><td><code>true</code></td><td>Optional</td><td><code>true</code> to use manifests to dynamically locate the base docker image.</td></tr>
<tr><td><code>docker.base.dynamic.stream</code></td><td><code>EI-Stable</code></td><td>Optional</td><td>Manifest stream to search within for manifests</td></tr>
<tr><td><code>docker.base.dynamic.version</code></td><td><code>${msx.release}</code></td><td>Optional</td><td>MSX release to search within for manifests</td></tr>
<tr><td><code>docker.base.dynamic.manifest</code></td><td><code>msxbase-bullseye-manifest</code></td><td>Optional</td><td>MSX manifest to search within for builds</td></tr>
<tr><td><code>docker.base.dynamic.image</code></td><td><code>msx-base-image</code></td><td>Optional</td><td>Manifest key identifying the image to use</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">docker:
    dockerfile: build/package/Dockerfile
</code></pre>
<h3 id="kubernetes"><a class="header" href="#kubernetes"><code>kubernetes</code></a></h3>
<p>The <code>kubernetes</code> configuration provides defaults for generating kubernetes manifests.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kubernetes.group</code></td><td><code>platformms</code></td><td>Optional</td><td>The kubernetes group used for pods in production.</td></tr>
</tbody></table>
</div>
<h3 id="manifest"><a class="header" href="#manifest"><code>manifest</code></a></h3>
<p>The <code>manifest</code> configuration specifies how to build and publish installer manifests.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>manifest.folder</code></td><td><code>Build-Stable</code></td><td>Optional</td><td>The maven output folder to publish the manifest to.</td></tr>
</tbody></table>
</div>
<h3 id="resources"><a class="header" href="#resources"><code>resources</code></a></h3>
<p>The <code>resources</code> section identifies the files to be included as part of the docker image.</p>
<p>Each entry has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>resources.includes</code></td><td>-</td><td>Optional</td><td>List of globs of files to include. Processed first.</td></tr>
<tr><td><code>resources.excludes</code></td><td>-</td><td>Optional</td><td>List of globs of files to exclude. Processed second.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">resources:
  includes:
    - &quot;/internal/migrate/**/*.sql&quot;
    - &quot;/internal/populate/**/*&quot;
  excludes:
    - &quot;/internal/populate/**/*.go&quot;
</code></pre>
<h3 id="assemblies"><a class="header" href="#assemblies"><code>assemblies</code></a></h3>
<p>The <code>assemblies</code> configuration specifies <code>.tar</code> file generation.  The <code>.tar</code> files will be included in generated
manifests and published (unless disabled).</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assemblies.root</code></td><td><code>platform-common</code></td><td>Optional</td><td>The folder from which assemblies are created by default. All sub-folders with a 'templates' folder or 'manifest.json' are included.</td></tr>
<tr><td><code>assemblies.custom</code></td><td>-</td><td>Optional</td><td>List of custom assemblies to include.  See <a href="build/docs/config.html#assembliescustom">below</a></td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">assemblies:
  root: platform-common
</code></pre>
<h4 id="assembliescustom"><a class="header" href="#assembliescustom"><code>assemblies.custom</code></a></h4>
<p>The <code>assemblies.custom</code> setting contains a list of custom assemblies to generate.  These
will be uploaded to artifactory and recorded as binaries in the manifest, unless disabled
with <code>artifactory.assemblies</code>.</p>
<p>Each entry in this list has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>-</td><td>Required</td><td>The root path of the assembly files.</td></tr>
<tr><td><code>path-prefix</code></td><td>-</td><td>Optional</td><td>A folder inside the assembly to prefix the files during the build.</td></tr>
<tr><td><code>manifest-prefix</code></td><td>-</td><td>Required</td><td>The prefix of the file name in the manifest.</td></tr>
<tr><td><code>manifest-key</code></td><td>-</td><td>Required</td><td>The location of the entry in the JSON manifest.</td></tr>
<tr><td><code>includes</code></td><td><code>/**/*</code></td><td>Optional</td><td>Glob of files to include.  Processed first.</td></tr>
<tr><td><code>excludes</code></td><td>-</td><td>Optional</td><td>Glob of files to exclude.  Processed second.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<p>To create an assembly file called &quot;skyfallui-files-${release}-${build}.tar&quot;:</p>
<pre><code class="language-yaml">assemblies:
  custom:
    - path: ui/build
      pathPrefix: services
      manifestPrefix: skyfallui-files
      manifestKey: ${msx.deploymentGroup}-ui
</code></pre>
<ul>
<li>Each file from the <code>ui/build</code> subtree will be prefixed with the <code>services</code> folder in the output tar.
e.g. 'ui/build/dna/index.js' will be relocated to <code>services/dna/index.js</code>.</li>
<li>The assembly will be added to the generated artifact manifests at e.g. <code>dna-ui</code>.</li>
</ul>
<h3 id="artifactory"><a class="header" href="#artifactory"><code>artifactory</code></a></h3>
<p>The <code>artifactory</code> configuration specifies artifactory connectivity, folders, binaries, and images.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>artifactory.assemblies</code></td><td><code>true</code></td><td>Optional</td><td>Include <a href="build/docs/config.html#assemblies">assemblies</a> in publishing and manifests</td></tr>
<tr><td><code>artifactory.installer</code></td><td><code>deployments/kubernetes</code></td><td>Optional</td><td>The folder in which installer binaries can be found.  eg pod, rc, meta templates.</td></tr>
<tr><td><code>artifactory.repository</code></td><td><code>https://.../vms-3.0-binaries</code></td><td>Optional</td><td>The base url for storing published artifacts</td></tr>
<tr><td><code>artifactory.installer-folder</code></td><td><code>binaries/vms-3.0-binaries</code></td><td>Optional</td><td>The folder prefix of binaries to record in the manifest</td></tr>
<tr><td><code>artifactory.username</code></td><td>-</td><td>Optional</td><td>The user name with which to authenticate to Artifactory.</td></tr>
<tr><td><code>artifactory.password</code></td><td>-</td><td>Optional</td><td>The password with which to authenticate to Artifactory.</td></tr>
<tr><td><code>artifactory.custom</code></td><td>-</td><td>Optional</td><td>List of custom binaries to include.  See <a href="build/docs/config.html#artifactorycustom">below</a></td></tr>
<tr><td><code>artifactory.images</code></td><td>-</td><td>Optional</td><td>List of docker images to include.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">artifactory:
  installer: deployments/production
  images:
    - nacservice
</code></pre>
<h4 id="artifactorycustom"><a class="header" href="#artifactorycustom"><code>artifactory.custom</code></a></h4>
<p>The <code>artifactory.custom</code> setting contains a list of custom binaries to include.  These
will be uploaded to artifactory and recorded in the manifest.</p>
<p>Each entry in this list has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>Required</td><td>The source path of the file to include.</td></tr>
<tr><td><code>output-name</code></td><td>Required</td><td>The destination name of the file.</td></tr>
<tr><td><code>manifest-prefix</code></td><td>Required</td><td>The prefix of the file name in the manifest.</td></tr>
<tr><td><code>manifest-key</code></td><td>Required</td><td>The location of the entry in the JSON manifest.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">artifactory:
  custom:
    - path: deploymentvariables/nac_deployment_variables.yml
      outputName: nac_deployment_variables.yml
      manifestPrefix: deployment-variables
      manifestKey: deployment_variables
    - path: deploymentvariables/nac_variables.yml
      outputName: nac_variables.yml
      manifestPrefix: variables
      manifestKey: variables    
</code></pre>
<h3 id="generate"><a class="header" href="#generate"><code>generate</code></a></h3>
<p>The <code>generate</code> configuration specifies paths to be generated by the <code>generate</code> target.
Mostly these will refer to folders on which to run <code>go generate</code> to produce mocks.<br />
Specialized generators such as <code>openapi</code> are described in following sections.</p>
<p><strong>NOTE:</strong> Embedding using vfs has been deprecated in favor of <code>go:embed</code> which executes
during the go build process.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>generate[*].path</code></td><td>-</td><td>Required</td><td>Folder to generate outputs</td></tr>
<tr><td><code>generate[*].command</code></td><td><code>go generate</code></td><td>Optional</td><td>Command to execute</td></tr>
</tbody></table>
</div>
<h3 id="generateopenapi"><a class="header" href="#generateopenapi"><code>generate[*].openapi</code></a></h3>
<p>The <code>openapi</code> generator can be used to auto-generate OpenApi clients from contract specifications.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>generate[*].openapi.spec</code></td><td>-</td><td>Required</td><td>Consumer contract location</td></tr>
<tr><td><code>generate[*].openapi.config</code></td><td>-</td><td>Required</td><td>OpenApi client generator config file</td></tr>
</tbody></table>
</div>
<h3 id="go"><a class="header" href="#go"><code>go</code></a></h3>
<p>The <code>go</code> configuration specifies environment variables and options to be passed to Go tools during the build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><code>go.env.all.*</code></td><td>Environment variables for all platforms</td></tr>
<tr><td><code>go.env.linux.*</code></td><td>Environment variables for linux platform</td></tr>
<tr><td><code>go.env.darwin.*</code></td><td>Environment variables for darwin (MacOS) platform</td></tr>
<tr><td><code>go.vet.options[*]</code></td><td>List of command line options to pass to <code>go vet</code></td></tr>
</tbody></table>
</div>
<h3 id="build"><a class="header" href="#build"><code>build</code></a></h3>
<p>The <code>build</code> configuration specifies information about the build used to generate <code>buildinfo.yml</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>build.number</code></td><td><code>SNAPSHOT</code></td><td>Required</td><td>The build number of this build.</td></tr>
<tr><td><code>build.group</code></td><td><code>com.cisco.msx</code></td><td>Optional</td><td>The build group.</td></tr>
</tbody></table>
</div>
<h3 id="infoapp"><a class="header" href="#infoapp"><code>info.app</code></a></h3>
<p>The <code>info.app</code> configuration specifies details about the application used across all parts of the build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>info.app.name</code></td><td>-</td><td>Required</td><td>The name of the application being built.</td></tr>
<tr><td><code>info.app.attributes.display-name</code></td><td>-</td><td>Required</td><td>The display name of the application being built.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">info.app:
    name: dnaservice
    attributes:
      displayName: DNA Microservice
</code></pre>
<h3 id="server"><a class="header" href="#server"><code>server</code></a></h3>
<p>The <code>server</code> configuration specifies details about the web server used across all parts of the build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>server.port</code></td><td>-</td><td>Required</td><td>The web server port of the application being built.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">server:
    port: 9393
</code></pre>
<h3 id="jenkins"><a class="header" href="#jenkins"><code>jenkins</code></a></h3>
<p>The <code>jenkins</code> configuration specifies details about the Jenkins CI server used by the project.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jenkins.job</code></td><td>-</td><td>Optional</td><td>The simplified job path to the Jenkins Job on the server.</td></tr>
<tr><td><code>jenkins.server</code></td><td><code>https://jenkins.infra.ciscomsx.com</code></td><td>Optional</td><td>The base url of the Jenkins CI server.</td></tr>
<tr><td><code>jenkins.username</code></td><td>-</td><td>Optional</td><td>User name to authenticate to Jenkins.</td></tr>
<tr><td><code>jenkins.password</code></td><td>-</td><td>Optional</td><td>API Token to authenticate to Jenkins. Can be created on the User Configure page in Jenkins UI.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">jenkins.job: eng-sp-umbrella/builds/umbrellaservice
</code></pre>
<h3 id="github"><a class="header" href="#github"><code>github</code></a></h3>
<p>The <code>github</code> configuration specifies details about the GitHub Source Control server used by the project.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>github.repository</code></td><td>'${spring.application.name}'</td><td>Optional</td><td>The name of the repository on the server.</td></tr>
<tr><td><code>github.organization</code></td><td>'NFV-BU'</td><td>Optional</td><td>The owner of the repository on the server.</td></tr>
<tr><td><code>github.server</code></td><td><code>https://cto-github.cisco.com</code></td><td>Optional</td><td>The base url of the GitHub server.</td></tr>
<tr><td><code>github.token</code></td><td>-</td><td>Optional</td><td>API Token to authenticate to GitHub. Can be created on the <code>User Settings &gt; Developer Settings &gt; Personal Access Tokens</code> page in the GitHub UI.</td></tr>
<tr><td><code>github.hook.push</code></td><td><code>${jenkins.server}/github-webhook/</code></td><td>Optional</td><td>Github Push Webhook to configure on the repository.</td></tr>
<tr><td><code>github.hook.pull-request</code></td><td><code>${jenkins.server}/ghprbhook/</code></td><td>Optional</td><td>Github PR Webhook to configure on the repository.</td></tr>
<tr><td><code>github.teams.jenkins</code></td><td><code>Jenkins-generic-users</code></td><td>Optional</td><td>GitHub CI Team to assign write access to the repository.</td></tr>
<tr><td><code>github.teams.eng</code></td><td>-</td><td>Optional</td><td>GitHub Engineering Team to assign write access to the repository.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">github.organization: xiaoydu
</code></pre>
<h3 id="aws"><a class="header" href="#aws"><code>aws</code></a></h3>
<p>The <code>aws</code> configuration specifies credentials and target details for AWS.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>aws.access-key-id</code></td><td><code>${aws.access.key.id}</code></td><td>Optional</td><td>Access Key Id to authenticate to AWS.</td></tr>
<tr><td><code>aws.secret-access-key</code></td><td><code>${aws.secret.access.key}</code></td><td>Optional</td><td>Secret Access Key to authenticate to AWS.</td></tr>
</tbody></table>
</div>
<p>These values default to the standard environment variables (<code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>) so
no extra configuration should be required if using them.</p>
<h3 id="deploy"><a class="header" href="#deploy"><code>deploy</code></a></h3>
<p>The <code>deploy</code> configuration specifies the target for package deployment.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>deploy.host</code></td><td>-</td><td>Required</td><td>SSH config host name to target for deployment.  Must point to an installer container.</td></tr>
</tbody></table>
</div>
<h3 id="openapi"><a class="header" href="#openapi"><code>openapi</code></a></h3>
<p>The <code>openapi</code> configuration specifies producer and consumer contract locations (local and upstream),
along with schema resolution aliases.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>openapi.spec</td><td><code>api/openapi.yaml</code></td><td>Optional</td><td>The project-root relative location of the producer contract specification.</td></tr>
<tr><td>openapi.contracts[*].consumer</td><td>-</td><td>Required</td><td>Local copy of the consumer contract for client generation.</td></tr>
<tr><td>openapi.contracts[*].producer</td><td>-</td><td>Required</td><td>Upstream copy of the producer contract for client generation.</td></tr>
<tr><td>openapi.alias[*].from</td><td>-</td><td>Required</td><td>Canonical schema url to be loaded from an alternative source</td></tr>
<tr><td>openapi.alias[*].to</td><td>-</td><td>Required</td><td>Alternative source location for schema</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml"># Contract Management
openapi:
  # Local (producer) API contract
  spec: api/openapi.yaml

  # Remote (consumer) API contract pairs
  contracts:
    - consumer: internal/stream/.openapi/manage-service-8.yaml
      producer: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/develop/manage-service-8.yaml

  # Alternative sources for well-known schema
  alias:
    - from: https://api.swaggerhub.com/domains/Cisco-Systems46/msx-common-domain/8
      to: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/sdk1.0.10/common-domain-8.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-targets"><a class="header" href="#build-targets">Build Targets</a></h1>
<p>go-msx Build has a collection of default build targets encompassing standard build steps that can be reused
in a project's Makefile.  The following chapters describe each of the standard build targets.</p>
<p>Users can also define custom build targets for project-specific needs.</p>
<h2 id="custom-build-targets"><a class="header" href="#custom-build-targets">Custom Build Targets</a></h2>
<p>Build targets can be added using the <code>build.AddTarget</code> function.  This will register a
CLI handler function for a new build target.  Build configuration can be accessed
vi the pkg.BuildConfiguration global variable from the handler function.  Ensure your
module containing the custom build target is initialized at startup by either:</p>
<ul>
<li>Defining your build target in the build <code>main</code> package of your project; or</li>
<li>Importing the module containing your custom build target from the build <code>main</code> package
of your project.</li>
</ul>
<p>Example:</p>
<pre><code class="language-go">package main

import build &quot;cto-github.cisco.com/NFV-BU/go-msx-build/pkg&quot;

var myCustomTargetFlag bool

func init() {
	cmd := build.AddTarget(&quot;custom-target&quot;, &quot;A custom build target&quot;, customTarget)
	cmd.Flags().BoolVarP(&amp;myCustomTargetFlag, &quot;enabled&quot;, &quot;e&quot;, false, &quot;Custom target option&quot;)
}

func customTarget(args []string) error {
	// custom target steps go here
	if myCustomTargetFlag {
		// ...
    }
	return nil
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-maintenance-build-targets"><a class="header" href="#project-maintenance-build-targets">Project Maintenance Build Targets</a></h1>
<h3 id="deploy-github-repo"><a class="header" href="#deploy-github-repo"><code>deploy-github-repo</code></a></h3>
<p>The <code>deploy-github-repo</code> target will create and/or reconfigure a GitHub repository with the appropriate users
and webhooks.</p>
<p>Target server and repository is configured via the <code>github.*</code> build <a href="build/docs/config.html#github">settings</a>.</p>
<h3 id="deploy-jenkins-job"><a class="header" href="#deploy-jenkins-job"><code>deploy-jenkins-job</code></a></h3>
<p>The <code>deploy-jenkins-job</code> target will upload your jenkins job as defined in the build/ci folder from <code>config.xml</code>.
This file will normally be auto-generated.</p>
<p>Target server and job is configured via the <code>jenkins.*</code> build <a href="build/docs/config.html#jenkins">settings</a>.</p>
<h3 id="update-go-msx"><a class="header" href="#update-go-msx"><code>update-go-msx</code></a></h3>
<p>The <code>update-go-msx</code> target will attempt to update your <code>go-msx</code> library to the latest version.</p>
<h3 id="update-go-msx-build"><a class="header" href="#update-go-msx-build"><code>update-go-msx-build</code></a></h3>
<p>The <code>update-go-msx-build</code> target will attempt to update your <code>go-msx-build</code> library to the latest version.</p>
<h3 id="update-go-msx-populator"><a class="header" href="#update-go-msx-populator"><code>update-go-msx-populator</code></a></h3>
<p>The <code>update-go-msx-populator</code> target will attempt to update your <code>go-msx-populator</code> library to the latest version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-targets"><a class="header" href="#development-targets">Development Targets</a></h1>
<h3 id="download-generate-deps"><a class="header" href="#download-generate-deps"><code>download-generate-deps</code></a></h3>
<p>The <code>download-generate-deps</code> target installs cross-project generation dependencies, including:</p>
<ul>
<li>github.com/rust-lang/mdBook</li>
<li>github.com/badboy/mdbook-mermaid</li>
<li>github.com/vektra/mockery/v2</li>
</ul>
<h3 id="generate-1"><a class="header" href="#generate-1"><code>generate</code></a></h3>
<p>The <code>generate</code> target will execute any custom (or default) generate commands defined in
the <code>generate.*</code> <a href="build/docs/config.html#generate">entries</a>.</p>
<p>If no command is specified for an entry, it will default to running <code>go generate</code> on that folder.</p>
<p>Generate commands can also be specified using <code>go:generate</code> <a href="https://blog.golang.org/generate">comments</a>.
Generation will be executed when <code>generate</code> executes on the directory containing files with these comments.</p>
<h3 id="go-fmt"><a class="header" href="#go-fmt"><code>go-fmt</code></a></h3>
<p>The <code>go-fmt</code> target executes <code>go fmt</code> on directories which contain <code>*.go</code> files (excluding the <code>vendor</code> directory).</p>
<h3 id="license-1"><a class="header" href="#license-1"><code>license</code></a></h3>
<p>The <code>license</code> target verifies that all go source code files contain the appropriate Cisco license header. </p>
<h3 id="update-openapi-producer-spec"><a class="header" href="#update-openapi-producer-spec"><code>update-openapi-producer-spec</code></a></h3>
<p>The <code>update-openapi-producer-spec</code> target will obtain the latest version of the
microservice <em>producer</em> OpenApi contract specification and overwrite the stored version.</p>
<p>Producer specification file is configured via the <code>openapi.spec</code> build <a href="build/docs/config.html#openapi">setting</a>.</p>
<h3 id="update-openapi-consumer-spec"><a class="header" href="#update-openapi-consumer-spec"><code>update-openapi-consumer-spec</code></a></h3>
<p>The <code>update-openapi-consumer-spec</code> target will obtain the latest version of the
<em>consumer</em> OpenApi contract specification and overwrite the stored version.</p>
<p>Consumer local and remote specification are configured via the <code>openapi.contracts[*]</code> build <a href="build/docs/config.html#openapi">setting</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifacts-build-targets"><a class="header" href="#artifacts-build-targets">Artifacts Build Targets</a></h1>
<h3 id="build-assemblies"><a class="header" href="#build-assemblies"><code>build-assemblies</code></a></h3>
<p>The <code>build-assemblies</code> target collects folders into tarballs and places their output into the staging
assembly folder (<code>dist/assembly</code>).</p>
<p>For each entry in <code>assembly.custom.*</code>, the target will create a tar file named <code>${prefix}-${release}-${build}.tar</code>.</p>
<h3 id="build-debug-executable"><a class="header" href="#build-debug-executable"><code>build-debug-executable</code></a></h3>
<p>The <code>build-debug-executable</code> target compiles the <code>main</code> module of the current application and outputs it
to the staging executable folder (<code>dist/root/usr/bin</code>).  Unlike <code>build-executable</code>, however it outputs a
binary suitable for debugging.  This can be included in a container to remotely debug the application.</p>
<h3 id="build-executable"><a class="header" href="#build-executable"><code>build-executable</code></a></h3>
<p>The <code>build-executable</code> target compiles the <code>main</code> module of the current application and outputs it to
the staging executable folder (<code>dist/root/usr/bin</code>).</p>
<p>Flags passed to <code>go build</code> can be customized using the <code>go.env.*.GOFLAGS</code> configuration.</p>
<h3 id="build-installer-manifest"><a class="header" href="#build-installer-manifest"><code>build-installer-manifest</code></a></h3>
<p>The <code>build-installer-manifest</code> target will create install manifests for integration servers and production
installation.  The contents of the manifests will be dynamically generated from the <code>artifactory</code> and <code>assemblies</code>
configuration, along with the docker image generated from the current build configuration.</p>
<p>To deploy the manifest artifact use the <code>publish-installer-manifest</code> target.</p>
<h3 id="build-package"><a class="header" href="#build-package"><code>build-package</code></a></h3>
<p>The <code>build-package</code> target will generate a Service package to be uploaded and deployed by the service pack deployer.
It will include the standard service contents, including assemblies, manifests, images, deployment variables, and
other binaries.</p>
<p>To deploy the package artifact use the <code>publish-package</code> target.</p>
<h3 id="build-tool"><a class="header" href="#build-tool"><code>build-tool</code></a></h3>
<p>The <code>build-tool</code> target will compile and generate a Tool binary distribution (.tar.gz) to be uploaded and deployed
to Artifactory (or elsewhere).  It will include the binary and any resources defined in the <code>tool</code> configuration
section.</p>
<p>NOTE: These binaries are statically compiled and therefore must not be distributed.</p>
<h3 id="docker-build"><a class="header" href="#docker-build"><code>docker-build</code></a></h3>
<p>The <code>docker-build</code> target will create a docker image for the current build configuration.  The contents of the
image are stages using <code>make dist</code> inside a build container, and then deployed onto an MSX base image to create
the runtime container image.</p>
<p>The base image can be specified using the <code>docker.repository</code> and <code>docker.base-image</code> configuration <a href="build/docs/config.html#docker">settings</a>.</p>
<p>The docker image will be named in the format <code>${docker.repository}/${info.app.name}:${release}-${build}</code>.</p>
<h3 id="docker-build-debug"><a class="header" href="#docker-build-debug"><code>docker-build-debug</code></a></h3>
<p>The <code>docker-build-debug</code> target will create a debugging docker image for the current build configuration.<br />
The contents of the image are stages using <code>make dist</code> inside a build container, and then deployed onto an 
MSX base image to create the runtime container image.</p>
<p>The base image can be specified using the <code>docker.repository</code> and <code>docker.base-image</code> configuration <a href="build/docs/config.html#docker">settings</a>.</p>
<p>The docker image will be named in the format <code>${docker.repository}/${info.app.name}:${release}-${build}</code>.</p>
<h3 id="download-generate-deps-1"><a class="header" href="#download-generate-deps-1"><code>download-generate-deps</code></a></h3>
<p>The <code>download-generate-deps</code> target installs cross-project generation dependencies, including:</p>
<ul>
<li>github.com/vektra/mockery</li>
<li>bou.ke/staticfiles</li>
</ul>
<h3 id="download-seccomp-dependencies"><a class="header" href="#download-seccomp-dependencies"><code>download-seccomp-dependencies</code></a></h3>
<p>The <code>download-seccomp-dependencies</code> target installs the seccomp-profiler for generating seccomp profiles.
See <code>generate-seccomp-profile</code>, below.</p>
<h3 id="generate-build-info"><a class="header" href="#generate-build-info"><code>generate-build-info</code></a></h3>
<p>The <code>generate-build-info</code> target creates the build-specific metadata file <code>buildinfo.yml</code>, including version information,
and build timestamps.</p>
<p>The metadata file is generated directly into the staging configuration folder (<code>dist/root/etc/${app.name}</code>).<br />
This file will be parsed on MSX Application startup during the configuration phase, and used to register the
service metadata with Consul.</p>
<p>Default values for the <code>info.build</code> fields should be specified in the application <code>bootstrap.yml</code> file to enable
local development before generating the metadata file.</p>
<h3 id="generate-deployment-variables"><a class="header" href="#generate-deployment-variables"><code>generate-deployment-variables</code></a></h3>
<p>The <code>generate-deployment-variables</code> target creates a YAML ansible variables file compatible with the MSX installer.
This file will be published during <code>publish</code>.</p>
<h3 id="generate-seccomp-profile"><a class="header" href="#generate-seccomp-profile"><code>generate-seccomp-profile</code></a></h3>
<p>The <code>generate-seccomp-profile</code> target creates the configuration file <code>seccomp.yml</code>, listing the expected set of linux
syscalls to be allowed during execution.  This prevents a compromised executable from making unauthorized syscalls.</p>
<h3 id="install-asyncapi-ui"><a class="header" href="#install-asyncapi-ui"><code>install-asyncapi-ui</code></a></h3>
<p>The <code>install-asyncapi-ui</code> target downloads the AsyncApi Studio package and extracts the
relevant files to the staging web folder (<code>dist/root/var/lib/${app.name}/www</code>)</p>
<h3 id="install-dependency-configs"><a class="header" href="#install-dependency-configs"><code>install-dependency-configs</code></a></h3>
<p>The <code>install-dependency-configs</code> target scans maven artifacts for <code>default-*.properties</code> files and copies them
into the staging configuration folder (<code>dist/root/etc/${app.name}</code>).  At runtime, a go-msx microservice will read these
files ensuring MSX microservices across frameworks have the same default configuration.</p>
<h3 id="install-executable-configs"><a class="header" href="#install-executable-configs"><code>install-executable-configs</code></a></h3>
<p>The <code>install-executable-configs</code> target copies configuration files from the <code>main</code> module of the application being
built to the staging configuration folder (<code>dist/root/etc/${app.name}</code>).</p>
<p>The list of configuration files to be copied is specified in the build configuration at <code>executable.config-files</code>:</p>
<pre><code class="language-yaml">executable:
  configFiles:
    - bootstrap.yml
    - dnaservice.production.yml
</code></pre>
<h3 id="install-extra-configs"><a class="header" href="#install-extra-configs"><code>install-extra-configs</code></a></h3>
<h3 id="install-resources"><a class="header" href="#install-resources"><code>install-resources</code></a></h3>
<p>The <code>install-resources</code> target copies static files from the project tree to the staging resources folder
(<code>dist/var/lib/${app.name}</code>).</p>
<p>The list of resources to be copied is specified in the build configuration at <code>resources.*</code>.</p>
<h3 id="install-swagger-ui"><a class="header" href="#install-swagger-ui"><code>install-swagger-ui</code></a></h3>
<p>The <code>install-swagger-ui</code> target downloads the Swagger UI webjar and MSX Swagger artifacts and extracts the
relevant files to the staging web folder (<code>dist/root/var/lib/${app.name}/www</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-build-targets"><a class="header" href="#verification-build-targets">Verification Build Targets</a></h1>
<h3 id="compare-openapi-consumer-spec"><a class="header" href="#compare-openapi-consumer-spec"><code>compare-openapi-consumer-spec</code></a></h3>
<p>The <code>compare-openapi-producer-spec</code> target will obtain the latest version of a
<em>consumer</em> OpenApi contract specification, as identified in the build configuration.
After obtaining the latest contract, it will compare it with the stored version,
and generate a report of the differences.</p>
<p>Consumer local and remote specification are configured via the <code>openapi.contracts[*]</code> build <a href="build/docs/config.html#openapi">setting</a>.</p>
<h3 id="compare-openapi-producer-spec"><a class="header" href="#compare-openapi-producer-spec"><code>compare-openapi-producer-spec</code></a></h3>
<p>The <code>compare-openapi-producer-spec</code> target will obtain the latest version of the
microservice <em>producer</em> OpenApi contract specification and compare it with the stored
version. After comparison, it will generate a report of the differences.</p>
<p>Producer specification file is configured via the <code>openapi.spec</code> build <a href="build/docs/config.html#openapi">setting</a>.</p>
<h3 id="compare-openapi-specs"><a class="header" href="#compare-openapi-specs"><code>compare-openapi-specs</code></a></h3>
<p>The <code>compare-openapi-specs</code> target will execute the <code>compare-openapi-producer-spec</code>
target, and then <code>compare-openapi-consumer-spec</code> target for each registered contract.
A summary report will be generated.</p>
<h3 id="download-test-deps"><a class="header" href="#download-test-deps"><code>download-test-deps</code></a></h3>
<p>The <code>download-test-deps</code> target installs cross-project test dependencies, including:</p>
<ul>
<li>github.com/axw/gocov/gocov</li>
<li>github.com/AlekSi/gocov-xml</li>
<li>github.com/stretchr/testify/assert</li>
<li>github.com/stretchr/testify/mock</li>
<li>github.com/stretchr/testify/http</li>
<li>github.com/pmezard/go-difflib/difflib</li>
<li>github.com/jstemmer/go-junit-report</li>
</ul>
<h3 id="execute-unit-tests"><a class="header" href="#execute-unit-tests"><code>execute-unit-tests</code></a></h3>
<p>The <code>execute-unit-tests</code> target searches for testable directories (those containing <code>*_test.go</code> files),
and invokes their unit tests while collecting line coverage data.  It then generates coverage reports
from the coverage data.</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Output File</th></tr></thead><tbody>
<tr><td>HTML</td><td><code>test/gocover.html</code></td></tr>
<tr><td>JUnit</td><td><code>test/junit-report.xml</code></td></tr>
<tr><td>Cobertura</td><td><code>test/cobertura-coverage.xml</code></td></tr>
</tbody></table>
</div>
<h3 id="go-vet"><a class="header" href="#go-vet"><code>go-vet</code></a></h3>
<p>The <code>go-vet</code> target executes <code>go vet</code> on directories which contain <code>*.go</code> files (excluding the <code>vendor</code> directory).
Options to pass to <code>go vet</code> can be specified in the build configuration under <code>go.vet.options</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-build-targets"><a class="header" href="#publishing-build-targets">Publishing Build Targets</a></h1>
<h3 id="deploy-package"><a class="header" href="#deploy-package"><code>deploy-package</code></a></h3>
<p>The <code>deploy-package</code> target will upload your already-built package tar-ball to a specified installer container.
The installer container ssh &quot;host&quot; must be properly configured in your <code>~/.ssh/config</code> file, for example:</p>
<pre><code class="language-ssh-config">Host installer-tme-dmz-01
    HostName rtp-dmz-bbhost.lab.ciscomsx.com
    User root
    Port 23556
    IdentityFile ~/.ssh/installer-tme-dmz.key
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
</code></pre>
<p>In this example, the installer container is named &quot;installer-tme-dmz-01&quot;.  This name should be passed to
using the <code>deploy.host</code> configuration, for example:</p>
<pre><code class="language-bash">go run build/cmd/build.go --config build/cmd/build.yml --deploy.host installer-tme-dmz-01 deploy-package
</code></pre>
<p>or</p>
<pre><code class="language-bash">DEPLOY_HOST=&quot;installer-tme-dmz-01&quot; make package-deploy
</code></pre>
<h3 id="docker-push"><a class="header" href="#docker-push"><code>docker-push</code></a></h3>
<p>The <code>docker-push</code> target will publish the local docker image generated using <code>docker-build</code> to the docker
repository specified in the current build configuration.</p>
<p>The repository can be specified using the <code>docker.repository</code> configuration setting.</p>
<h3 id="docker-save"><a class="header" href="#docker-save"><code>docker-save</code></a></h3>
<p>The <code>docker-save</code> target will output the local docker image generated using <code>docker-build</code> to a tar file
named <code>${info.app.name}.tar</code> in the current directory.  The tarred image will include the original repository and
image tag.</p>
<h3 id="git-tag"><a class="header" href="#git-tag"><code>git-tag</code></a></h3>
<p>The <code>git-tag</code> target re-creates and overwrites any local and remote tags for the current version <code>${release}-${build}</code>.</p>
<p>This is commonly used after publish to tag the source repo with the build.</p>
<h3 id="publish-binaries"><a class="header" href="#publish-binaries"><code>publish-binaries</code></a></h3>
<p>The <code>publish-binaries</code> target will deploy any assemblies and other installer binaries to artifactory.</p>
<p>The remote repository folder is specified through <code>artifactory.repository</code>.  Within the repository folder,
artifacts will be placed underneath <code>${msx.deploymentGroup}/${release}-${build}/</code> to isolate files from
each build and deployment group.</p>
<p>Binaries are specified in the <code>artifactory</code> configuration.  Assembly publishing can be disabled
setting the <code>artifactory.assemblies</code> to <code>false</code>.</p>
<h3 id="publish-installer-manifest"><a class="header" href="#publish-installer-manifest"><code>publish-installer-manifest</code></a></h3>
<p>The <code>publish-installer-manifest</code> target executes Maven to deploy the manifest for the current build configuration.</p>
<h3 id="publish-package"><a class="header" href="#publish-package"><code>publish-package</code></a></h3>
<p>The <code>publish-package</code> target will use your local S3 client to upload the service package to S3.  The correct S3 folder
will automatically be calculated.  Your S3 client (<code>aws s3 ...</code>) should be properly configured with credentials either
using environment variables or configuration files.</p>
<h3 id="publish-tool"><a class="header" href="#publish-tool"><code>publish-tool</code></a></h3>
<p>The <code>publish-tool</code> target will upload the tool distribution packages (built with <code>build-tool</code>) to Artifactory.
Versioned and Latest will be published for easy URL distribution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checks"><a class="header" href="#checks">Checks</a></h1>
<p>See the internal <a href="https://cto-github.cisco.com/NFV-BU/buildservice/blob/master/docs/README.md">Checks</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<ul>
<li>
<p>Ensure you create a meaningfully named topic branch for your code:</p>
<p><code>feature/sql-transactions</code></p>
<p><code>bugfix/populate-error-handling</code></p>
</li>
<li>
<p>Make your code changes</p>
</li>
<li>
<p>Run <code>make precommit</code> to regenerate, reformat, license, etc.</p>
</li>
<li>
<p>Commit your code to your topic branch</p>
</li>
<li>
<p>Rebase your topic branch onto master (do not reverse merge master into your branch)</p>
</li>
<li>
<p>Ensure your commits are cohesive, or just squash them</p>
</li>
<li>
<p>Create a Pull Request with a meaningful title similar to your topic branch name</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skel-execution-sequence"><a class="header" href="#skel-execution-sequence">Skel Execution Sequence</a></h1>
<h2 id="program-flow"><a class="header" href="#program-flow">Program flow</a></h2>
<ol>
<li><code>cmd/skel/skel.go</code> is skel's main function. It calls the run method from the 
skel package (in <code>skel/</code>), passing in a build number, which, in turn, is passed
in during build via <code>ldflags</code> from <code>build-tool</code>'s <code>BuildConfig</code> (<code>build-tool</code> is in <code>build/tool.go</code>)</li>
<li>the skel package init loads skel templates into a map from the embedded filesystem</li>
<li>it also sets up pre-run project and generation configuration loading routines that will be called before each command is run</li>
<li>config is loaded into a package-level variable called skeletonConfig</li>
<li>if skel does not find a pre-existing project in the current dir (by looking for <code>.skel.json</code>) it diverts to the interactive menus</li>
<li>the menus are navigated in <code>skel/configure.go</code> which simply fills in the values into skeletonConfig which is declared therein </li>
<li>skel then routes on via the <code>cli/</code> package in order to enable cobra command processing (<code>github.com/spf13/cobra</code>)</li>
<li>(aside: the actual skel generation targets are defined and registered in <code>skel/skeleton.go</code> which comprises the heart of skel)</li>
<li>each target/command is called using its string key after the machinery in skeleton.go adds common pre and post generator keys to the list of those to be run</li>
<li>The sandwich filling between the pre and post slices of generators is derived from the archetype (see <code>skel/archetype.go</code>)</li>
<li>in addition to pre and post generators, there are some that must be run explicitly by using cli commands (see <a href="skel/docs/sequence.html#generator-groupings">groupings</a> )</li>
<li>once the complete list of generators to be run has been assembled, they are executed in order</li>
<li>each target/command/generator will typically:
a. call out to OS level routines using the <code>gopkg.in/pipe.v2</code> lib
b. fill out substitutions and apply templates using the routines in <code>render.go</code> which provides many options</li>
<li><em>fin</em></li>
</ol>
<p>In general, <code>skel</code> simply creates new files, overwriting any that might exist before them; however, most of the targets do not overlap, and may be freely run in any order, or, in the case of Domain and AsyncAPI may be run mutiple times to build up additional variants.</p>
<h2 id="completion-scripts-oddity"><a class="header" href="#completion-scripts-oddity">Completion Scripts Oddity</a></h2>
<p>The completion script target is an oddity in that it sends its output to <stdout>. If you happen to send logs to <stdout> before this target has finished, the scripts will contain log lines, which, at best, will result in the scripts failing when users try to run them :(. Be sure that all early logging is at the 'DEBUG' or 'TRACE' levels therefore.</p>
<h2 id="domain-generation"><a class="header" href="#domain-generation">Domain generation</a></h2>
<h2 id="asyncapi-generation"><a class="header" href="#asyncapi-generation">AsyncAPI generation</a></h2>
<h2 id="generator-groupings"><a class="header" href="#generator-groupings">Generator groupings</a></h2>
<p>(sp = service pack)</p>
<h3 id="pre-generators"><a class="header" href="#pre-generators">Pre generators</a></h3>
<p><code>generate-skel-json</code>            Create the skel configuration file<br />
<code>generate-build</code>                Create makefile, build.go, build.yml<br />
<code>generate-app</code>                  Readme, go.mod, main.go, 2 yml
<code>generate-test</code>                 internal/empty_test.go</p>
<h3 id="archetype-specific"><a class="header" href="#archetype-specific">Archetype specific</a></h3>
<p><code>generate-migrate</code>              (beat,sp) Create the migrate package<br />
<code>generate-domain-beats</code>         (beat) Generate beats domain implementation<br />
<code>generate-service-pack</code>         (sp) Generate service pack implementation<br />
<code>generate-kubernetes</code>           (all) Create production kubernetes manifest templates</p>
<h3 id="post"><a class="header" href="#post">Post</a></h3>
<p><code>generate-deployment-variables</code> deployment_variables.yml<br />
<code>add-go-msx-dependency </code>        Adds go modules appropriate to the archetype<br />
<code>generate-local        </code>        local&amp;remote address, consul/vault<br />
<code>generate-manifest     </code>        installer manifest (maven)<br />
<code>generate-dockerfile   </code>        dockerfile: build and distn<br />
<code>generate-goland       </code>        Create a Goland project for the application<br />
<code>generate-vscode       </code>        Create a VSCode project for the application<br />
<code>generate-jenkins      </code>        Create Jenkins CI templates<br />
<code>generate-github       </code>        Create github configuration files<br />
<code>generate-git          </code>        Create git repository</p>
<h3 id="called-explicitly"><a class="header" href="#called-explicitly">Called explicitly</a></h3>
<p><code>completion</code>                    autocompletion script for the specified shell<br />
<code>generate-certificate</code>          Generate an X.509 server certificate and private key</p>
<p><code>generate-channel</code>              Create async channel<br />
<code>generate-channel-asyncapi</code>     Create stream from AsyncApi 2.4 specification<br />
<code>generate-channel-publisher</code>    Create async channel publisher<br />
<code>generate-channel-subscriber</code>   Create async channel subscriber</p>
<p><code>generate-domain-openapi</code>       Create domains from OpenAPI 3.0 manifest<br />
<code>generate-domain-system </code>       Generate system domain implementation<br />
<code>generate-domain-tenant</code>        Generate tenant domain implementation</p>
<p><code>generate-timer</code>                Generate timer implementation<br />
<code>generate-topic-publisher</code>      Generate publisher topic implementation<br />
<code>generate-topic-subscriber</code>     Generate subscriber topic implementation<br />
<code>generate-webservices</code>          Create web services from swagger manifest</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-skel-template-functions"><a class="header" href="#using-skel-template-functions">Using Skel template functions</a></h1>
<h2 id="general-structure"><a class="header" href="#general-structure">General Structure</a></h2>
<p>Skel uses <code>targets</code>, which are groups of associated generating actions. Typically, a target will perform substitutions on a set of template files, emit them to appropriate directories in the generated tree and may perform shell functions (e.g. <code>git</code> etc.) thereafter to complete the generated application.</p>
<p>Internally, targets are identified by unique strings which allow target lists to be manipulated easily. Each target generally also has a corresponding <code>skel</code> cli subcommand which will execute it.</p>
<h2 id="file-types"><a class="header" href="#file-types">File types</a></h2>
<p>Skel can template any text file-type, but specifically recognizes the extensions for go, make, json, sql, yaml, groovy, properties, md, go-mod, docker, shell, js, ts and jenkins files.</p>
<h2 id="substitution"><a class="header" href="#substitution">Substitution</a></h2>
<p>Skel does substitutions into template files in three phases:</p>
<ol>
<li>It substitutes particular <code>Strings</code> verbatim; these are passed into the rednering functions via the RenderOptions struct</li>
<li>It then substitutes variable values for the text in the templates matching <code>${variable}</code>. e.g. application name would be substituted for <code>${app.name}</code>. The possible variables are listed in skel/render.go around line 95.</li>
<li>It then evaluates conditional blocks (see below) </li>
</ol>
<p>For example, this piece of dockerfile:</p>
<pre><code class="language-dockerfile">FROM ${BASE_IMAGE}
EXPOSE ${server.port}
EXPOSE ${debug.port}

ENV SERVICE_BIN &quot;/usr/bin/${app.name}&quot;
COPY --from=debug-builder /app/dist/root/ /
COPY --from=debug-builder /go/bin/dlv /usr/bin
</code></pre>
<p>An easier option than pawing around in the source code: available substitutions and conditionals may be listed by executing a <code>skel</code> generation with the debug or trace loglevels: <code>skel -l=DEBUG</code> -- they will be printed as part of the render options log lines.</p>
<h2 id="conditional-blocks"><a class="header" href="#conditional-blocks">Conditional Blocks</a></h2>
<p>These are defined by conditional markers and the words <code>if</code>, <code>else</code> and <code>endif</code>. Conditional markers vary by file type:</p>
<ul>
<li>make, yaml, properties, docker, bash: <code>#</code></li>
<li>sql: <code>--#</code></li>
<li>xml, md: <code>&lt;--#, --&gt;</code></li>
<li>everything else: <code>//#</code></li>
</ul>
<p>For example, the following block in a Makefile includes different lists depending on the app archetype:</p>
<pre><code class="language-makefile">#if GENERATOR_APP
all: clean deps vet test docker assemblies deployment manifest
#endif GENERATOR_APP
#if GENERATOR_BEAT
all: clean deps vet test docker deployment manifest package
#endif GENERATOR_BEAT
#if GENERATOR_SP
all: clean deps vet test docker assemblies deployment manifest package
#endif GENERATOR_SP
</code></pre>
<h2 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h2>
<p>As a cross-check mechanism, Skel is provided with the ability to insist whether files already exist or not during generation, and to halt if something is unexpected. The options are:</p>
<ul>
<li>Add: either add the file or replace it, we care not</li>
<li>New: must not exist before, halt if it does</li>
<li>AddNoOverwrite: May add it, or skip it, but don't halt</li>
<li>Replace: must exist and we replace it</li>
<li>Delete: must exist (or we halt) then we delete it</li>
<li>Gone: delete it if it exists, don't halt</li>
</ul>
<h2 id="file-names"><a class="header" href="#file-names">File Names</a></h2>
<p>Each template file has a source filename, which is in the embedded filesystem of templates, and a destination filename, which is relative to the root of the generated project.</p>
<p>Variables may be substituted into filenames, of either type, using the same syntax as within templates. e.g. <code>&quot;local/${app.name}.remote.yml&quot;</code></p>
<p>If a dest file name is not provided, it is assumed to the same as the source.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="book/mermaid.min.js"></script>
        <script type="text/javascript" src="book/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
