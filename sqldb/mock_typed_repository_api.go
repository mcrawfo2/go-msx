// Code generated by mockery v2.22.1. DO NOT EDIT.

package sqldb

import (
	context "context"

	goqu "github.com/doug-martin/goqu/v9"
	exp "github.com/doug-martin/goqu/v9/exp"

	mock "github.com/stretchr/testify/mock"

	paging "cto-github.cisco.com/NFV-BU/go-msx/paging"
)

// MockTypedRepositoryApi is an autogenerated mock type for the TypedRepositoryApi type
type MockTypedRepositoryApi[I interface{}] struct {
	mock.Mock
}

type MockTypedRepositoryApi_Expecter[I interface{}] struct {
	mock *mock.Mock
}

func (_m *MockTypedRepositoryApi[I]) EXPECT() *MockTypedRepositoryApi_Expecter[I] {
	return &MockTypedRepositoryApi_Expecter[I]{mock: &_m.Mock}
}

// CountAll provides a mock function with given fields: ctx, dest, where
func (_m *MockTypedRepositoryApi[I]) CountAll(ctx context.Context, dest *int64, where WhereOption) error {
	ret := _m.Called(ctx, dest, where)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64, WhereOption) error); ok {
		r0 = rf(ctx, dest, where)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_CountAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountAll'
type MockTypedRepositoryApi_CountAll_Call[I interface{}] struct {
	*mock.Call
}

// CountAll is a helper method to define mock.On call
//   - ctx context.Context
//   - dest *int64
//   - where WhereOption
func (_e *MockTypedRepositoryApi_Expecter[I]) CountAll(ctx interface{}, dest interface{}, where interface{}) *MockTypedRepositoryApi_CountAll_Call[I] {
	return &MockTypedRepositoryApi_CountAll_Call[I]{Call: _e.mock.On("CountAll", ctx, dest, where)}
}

func (_c *MockTypedRepositoryApi_CountAll_Call[I]) Run(run func(ctx context.Context, dest *int64, where WhereOption)) *MockTypedRepositoryApi_CountAll_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64), args[2].(WhereOption))
	})
	return _c
}

func (_c *MockTypedRepositoryApi_CountAll_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_CountAll_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_CountAll_Call[I]) RunAndReturn(run func(context.Context, *int64, WhereOption) error) *MockTypedRepositoryApi_CountAll_Call[I] {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function with given fields: ctx, where
func (_m *MockTypedRepositoryApi[I]) DeleteAll(ctx context.Context, where WhereOption) error {
	ret := _m.Called(ctx, where)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, WhereOption) error); ok {
		r0 = rf(ctx, where)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type MockTypedRepositoryApi_DeleteAll_Call[I interface{}] struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
//   - ctx context.Context
//   - where WhereOption
func (_e *MockTypedRepositoryApi_Expecter[I]) DeleteAll(ctx interface{}, where interface{}) *MockTypedRepositoryApi_DeleteAll_Call[I] {
	return &MockTypedRepositoryApi_DeleteAll_Call[I]{Call: _e.mock.On("DeleteAll", ctx, where)}
}

func (_c *MockTypedRepositoryApi_DeleteAll_Call[I]) Run(run func(ctx context.Context, where WhereOption)) *MockTypedRepositoryApi_DeleteAll_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(WhereOption))
	})
	return _c
}

func (_c *MockTypedRepositoryApi_DeleteAll_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_DeleteAll_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_DeleteAll_Call[I]) RunAndReturn(run func(context.Context, WhereOption) error) *MockTypedRepositoryApi_DeleteAll_Call[I] {
	_c.Call.Return(run)
	return _c
}

// DeleteOne provides a mock function with given fields: ctx, keys
func (_m *MockTypedRepositoryApi[I]) DeleteOne(ctx context.Context, keys exp.Ex) error {
	ret := _m.Called(ctx, keys)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, exp.Ex) error); ok {
		r0 = rf(ctx, keys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_DeleteOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOne'
type MockTypedRepositoryApi_DeleteOne_Call[I interface{}] struct {
	*mock.Call
}

// DeleteOne is a helper method to define mock.On call
//   - ctx context.Context
//   - keys exp.Ex
func (_e *MockTypedRepositoryApi_Expecter[I]) DeleteOne(ctx interface{}, keys interface{}) *MockTypedRepositoryApi_DeleteOne_Call[I] {
	return &MockTypedRepositoryApi_DeleteOne_Call[I]{Call: _e.mock.On("DeleteOne", ctx, keys)}
}

func (_c *MockTypedRepositoryApi_DeleteOne_Call[I]) Run(run func(ctx context.Context, keys exp.Ex)) *MockTypedRepositoryApi_DeleteOne_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(exp.Ex))
	})
	return _c
}

func (_c *MockTypedRepositoryApi_DeleteOne_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_DeleteOne_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_DeleteOne_Call[I]) RunAndReturn(run func(context.Context, exp.Ex) error) *MockTypedRepositoryApi_DeleteOne_Call[I] {
	_c.Call.Return(run)
	return _c
}

// FindAll provides a mock function with given fields: ctx, dest, options
func (_m *MockTypedRepositoryApi[I]) FindAll(ctx context.Context, dest *[]I, options ...func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request)) (paging.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 paging.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *[]I, ...func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request)) (paging.Response, error)); ok {
		return rf(ctx, dest, options...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *[]I, ...func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request)) paging.Response); ok {
		r0 = rf(ctx, dest, options...)
	} else {
		r0 = ret.Get(0).(paging.Response)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *[]I, ...func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request)) error); ok {
		r1 = rf(ctx, dest, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockTypedRepositoryApi_FindAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindAll'
type MockTypedRepositoryApi_FindAll_Call[I interface{}] struct {
	*mock.Call
}

// FindAll is a helper method to define mock.On call
//   - ctx context.Context
//   - dest *[]I
//   - options ...func(*goqu.SelectDataset , paging.Request)(*goqu.SelectDataset , paging.Request)
func (_e *MockTypedRepositoryApi_Expecter[I]) FindAll(ctx interface{}, dest interface{}, options ...interface{}) *MockTypedRepositoryApi_FindAll_Call[I] {
	return &MockTypedRepositoryApi_FindAll_Call[I]{Call: _e.mock.On("FindAll",
		append([]interface{}{ctx, dest}, options...)...)}
}

func (_c *MockTypedRepositoryApi_FindAll_Call[I]) Run(run func(ctx context.Context, dest *[]I, options ...func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request))) *MockTypedRepositoryApi_FindAll_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request))
			}
		}
		run(args[0].(context.Context), args[1].(*[]I), variadicArgs...)
	})
	return _c
}

func (_c *MockTypedRepositoryApi_FindAll_Call[I]) Return(pagingResponse paging.Response, err error) *MockTypedRepositoryApi_FindAll_Call[I] {
	_c.Call.Return(pagingResponse, err)
	return _c
}

func (_c *MockTypedRepositoryApi_FindAll_Call[I]) RunAndReturn(run func(context.Context, *[]I, ...func(*goqu.SelectDataset, paging.Request) (*goqu.SelectDataset, paging.Request)) (paging.Response, error)) *MockTypedRepositoryApi_FindAll_Call[I] {
	_c.Call.Return(run)
	return _c
}

// FindOne provides a mock function with given fields: ctx, dest, where
func (_m *MockTypedRepositoryApi[I]) FindOne(ctx context.Context, dest *I, where WhereOption) error {
	ret := _m.Called(ctx, dest, where)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *I, WhereOption) error); ok {
		r0 = rf(ctx, dest, where)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_FindOne_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOne'
type MockTypedRepositoryApi_FindOne_Call[I interface{}] struct {
	*mock.Call
}

// FindOne is a helper method to define mock.On call
//   - ctx context.Context
//   - dest *I
//   - where WhereOption
func (_e *MockTypedRepositoryApi_Expecter[I]) FindOne(ctx interface{}, dest interface{}, where interface{}) *MockTypedRepositoryApi_FindOne_Call[I] {
	return &MockTypedRepositoryApi_FindOne_Call[I]{Call: _e.mock.On("FindOne", ctx, dest, where)}
}

func (_c *MockTypedRepositoryApi_FindOne_Call[I]) Run(run func(ctx context.Context, dest *I, where WhereOption)) *MockTypedRepositoryApi_FindOne_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*I), args[2].(WhereOption))
	})
	return _c
}

func (_c *MockTypedRepositoryApi_FindOne_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_FindOne_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_FindOne_Call[I]) RunAndReturn(run func(context.Context, *I, WhereOption) error) *MockTypedRepositoryApi_FindOne_Call[I] {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: ctx, value
func (_m *MockTypedRepositoryApi[I]) Insert(ctx context.Context, value ...I) error {
	_va := make([]interface{}, len(value))
	for _i := range value {
		_va[_i] = value[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...I) error); ok {
		r0 = rf(ctx, value...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MockTypedRepositoryApi_Insert_Call[I interface{}] struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ctx context.Context
//   - value ...I
func (_e *MockTypedRepositoryApi_Expecter[I]) Insert(ctx interface{}, value ...interface{}) *MockTypedRepositoryApi_Insert_Call[I] {
	return &MockTypedRepositoryApi_Insert_Call[I]{Call: _e.mock.On("Insert",
		append([]interface{}{ctx}, value...)...)}
}

func (_c *MockTypedRepositoryApi_Insert_Call[I]) Run(run func(ctx context.Context, value ...I)) *MockTypedRepositoryApi_Insert_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]I, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(I)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockTypedRepositoryApi_Insert_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_Insert_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_Insert_Call[I]) RunAndReturn(run func(context.Context, ...I) error) *MockTypedRepositoryApi_Insert_Call[I] {
	_c.Call.Return(run)
	return _c
}

// Truncate provides a mock function with given fields: ctx
func (_m *MockTypedRepositoryApi[I]) Truncate(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_Truncate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Truncate'
type MockTypedRepositoryApi_Truncate_Call[I interface{}] struct {
	*mock.Call
}

// Truncate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTypedRepositoryApi_Expecter[I]) Truncate(ctx interface{}) *MockTypedRepositoryApi_Truncate_Call[I] {
	return &MockTypedRepositoryApi_Truncate_Call[I]{Call: _e.mock.On("Truncate", ctx)}
}

func (_c *MockTypedRepositoryApi_Truncate_Call[I]) Run(run func(ctx context.Context)) *MockTypedRepositoryApi_Truncate_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockTypedRepositoryApi_Truncate_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_Truncate_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_Truncate_Call[I]) RunAndReturn(run func(context.Context) error) *MockTypedRepositoryApi_Truncate_Call[I] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, where, value
func (_m *MockTypedRepositoryApi[I]) Update(ctx context.Context, where WhereOption, value I) error {
	ret := _m.Called(ctx, where, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, WhereOption, I) error); ok {
		r0 = rf(ctx, where, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockTypedRepositoryApi_Update_Call[I interface{}] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - where WhereOption
//   - value I
func (_e *MockTypedRepositoryApi_Expecter[I]) Update(ctx interface{}, where interface{}, value interface{}) *MockTypedRepositoryApi_Update_Call[I] {
	return &MockTypedRepositoryApi_Update_Call[I]{Call: _e.mock.On("Update", ctx, where, value)}
}

func (_c *MockTypedRepositoryApi_Update_Call[I]) Run(run func(ctx context.Context, where WhereOption, value I)) *MockTypedRepositoryApi_Update_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(WhereOption), args[2].(I))
	})
	return _c
}

func (_c *MockTypedRepositoryApi_Update_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_Update_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_Update_Call[I]) RunAndReturn(run func(context.Context, WhereOption, I) error) *MockTypedRepositoryApi_Update_Call[I] {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function with given fields: ctx, value
func (_m *MockTypedRepositoryApi[I]) Upsert(ctx context.Context, value ...I) error {
	_va := make([]interface{}, len(value))
	for _i := range value {
		_va[_i] = value[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...I) error); ok {
		r0 = rf(ctx, value...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockTypedRepositoryApi_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MockTypedRepositoryApi_Upsert_Call[I interface{}] struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - value ...I
func (_e *MockTypedRepositoryApi_Expecter[I]) Upsert(ctx interface{}, value ...interface{}) *MockTypedRepositoryApi_Upsert_Call[I] {
	return &MockTypedRepositoryApi_Upsert_Call[I]{Call: _e.mock.On("Upsert",
		append([]interface{}{ctx}, value...)...)}
}

func (_c *MockTypedRepositoryApi_Upsert_Call[I]) Run(run func(ctx context.Context, value ...I)) *MockTypedRepositoryApi_Upsert_Call[I] {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]I, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(I)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockTypedRepositoryApi_Upsert_Call[I]) Return(_a0 error) *MockTypedRepositoryApi_Upsert_Call[I] {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockTypedRepositoryApi_Upsert_Call[I]) RunAndReturn(run func(context.Context, ...I) error) *MockTypedRepositoryApi_Upsert_Call[I] {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockTypedRepositoryApi interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockTypedRepositoryApi creates a new instance of MockTypedRepositoryApi. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockTypedRepositoryApi[I interface{}](t mockConstructorTestingTNewMockTypedRepositoryApi) *MockTypedRepositoryApi[I] {
	mock := &MockTypedRepositoryApi[I]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
